<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>Twilight</title>
<style>
body {
  margin: 0;
  background: #000;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
  overflow: hidden;
  touch-action: none;
  font-family: monospace;
  overscroll-behavior: none;
  -webkit-overflow-scrolling: touch;
}
canvas {
  image-rendering: pixelated;
  image-rendering: crisp-edges;
  image-rendering: -moz-crisp-edges;
  image-rendering: optimize-contrast;
  /* JS will set width/height dynamically */
}

/* ===== MOBILE CONTROLS - RETRO GAMEPAD LAYOUT ===== */
.mobile-controls {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  pointer-events: none;
  z-index: 100;
  display: flex;
}

/* Left Side: D-Pad Style Movement */
.dpad-container {
  position: absolute;
  left: max(15px, env(safe-area-inset-left, 15px));
  bottom: max(15px, env(safe-area-inset-bottom, 15px));
  pointer-events: auto;
  display: grid;
  grid-template-columns: 60px 60px 60px;
  grid-template-rows: 60px 60px;
  gap: 4px;
  filter: drop-shadow(0 8px 24px rgba(120, 150, 255, 0.4));
}

.dpad-btn {
  width: 60px;
  height: 60px;
  background: linear-gradient(145deg, rgba(40, 45, 70, 0.9), rgba(25, 30, 50, 0.95));
  border: 2px solid rgba(120, 150, 255, 0.6);
  border-radius: 8px;
  color: rgba(180, 200, 255, 0.95);
  font-size: 28px;
  font-weight: bold;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 
    inset 0 1px 0 rgba(120, 150, 255, 0.3),
    0 4px 12px rgba(0, 0, 0, 0.5);
  transition: all 0.1s cubic-bezier(0.4, 0, 0.2, 1);
  user-select: none;
  touch-action: manipulation;
  position: relative;
  overflow: hidden;
}

.dpad-btn::before {
  content: '';
  position: absolute;
  inset: -10px;
  background: transparent;
}

.dpad-btn::after {
  content: '';
  position: absolute;
  inset: 0;
  background: radial-gradient(circle at center, rgba(120, 150, 255, 0.3), transparent);
  opacity: 0;
  transition: opacity 0.15s;
}

.dpad-btn.pressed {
  transform: scale(0.92) translateY(2px);
  background: linear-gradient(145deg, rgba(60, 70, 110, 1), rgba(40, 50, 80, 1));
  border-color: rgba(150, 180, 255, 0.9);
  box-shadow: 
    inset 0 2px 8px rgba(0, 0, 0, 0.6),
    0 2px 8px rgba(120, 150, 255, 0.5);
}

.dpad-btn.pressed::after {
  opacity: 1;
}

/* D-Pad Grid Positions */
.dpad-outfit { grid-column: 1; grid-row: 1; }
.dpad-whistle { grid-column: 2; grid-row: 1; }
.dpad-left { grid-column: 1; grid-row: 2; }
.dpad-right { grid-column: 2; grid-row: 2; }

/* Right Side: Action Buttons Cluster */
.action-cluster {
  position: absolute;
  right: max(15px, env(safe-area-inset-right, 15px));
  bottom: max(15px, env(safe-area-inset-bottom, 15px));
  pointer-events: auto;
  display: flex;
  flex-direction: column;
  gap: 10px;
  filter: drop-shadow(0 8px 24px rgba(255, 180, 120, 0.3));
}

.action-row {
  display: flex;
  gap: 10px;
  justify-content: flex-end;
}

.action-btn {
  width: 64px;
  height: 64px;
  border-radius: 50%;
  background: linear-gradient(145deg, rgba(70, 50, 40, 0.9), rgba(50, 35, 30, 0.95));
  border: 3px solid rgba(255, 200, 150, 0.6);
  color: rgba(255, 220, 180, 0.95);
  font-size: 16px;
  font-weight: bold;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
  gap: 2px;
  box-shadow: 
    inset 0 1px 0 rgba(255, 200, 150, 0.3),
    0 6px 16px rgba(0, 0, 0, 0.5);
  transition: all 0.1s cubic-bezier(0.4, 0, 0.2, 1);
  user-select: none;
  touch-action: manipulation;
  position: relative;
  overflow: hidden;
}

.action-btn::before {
  content: '';
  position: absolute;
  inset: -10px;
  background: transparent;
}

.action-btn::after {
  content: '';
  position: absolute;
  inset: 0;
  background: radial-gradient(circle at center, rgba(255, 200, 150, 0.3), transparent);
  opacity: 0;
  transition: opacity 0.15s;
  border-radius: 50%;
}

.action-btn.pressed {
  transform: scale(0.90) translateY(3px);
  background: linear-gradient(145deg, rgba(100, 70, 50, 1), rgba(70, 50, 40, 1));
  border-color: rgba(255, 220, 180, 0.9);
  box-shadow: 
    inset 0 2px 8px rgba(0, 0, 0, 0.6),
    0 3px 12px rgba(255, 200, 150, 0.5);
}

.action-btn.pressed::after {
  opacity: 1;
}

.action-btn .emoji {
  font-size: 28px; /* Larger since no label */
  line-height: 1;
}

.action-btn .label {
  display: none; /* Hide all text labels */
}

/* Special styling for primary actions */
.action-btn.primary {
  border-width: 3px;
  border-color: rgba(255, 220, 120, 0.8);
  box-shadow: 
    inset 0 1px 0 rgba(255, 220, 120, 0.4),
    0 6px 20px rgba(255, 200, 100, 0.4);
}

/* Hide on desktop */
@media (min-width: 1025px) {
  .mobile-controls {
    display: none !important;
  }
}

/* Landscape mode optimization */
@media (max-height: 500px) and (orientation: landscape) {
  .dpad-container, .action-cluster {
    bottom: max(10px, env(safe-area-inset-bottom, 10px));
  }
  .dpad-btn {
    width: 50px;
    height: 50px;
    font-size: 24px;
  }
  .action-btn {
    width: 54px;
    height: 54px;
    font-size: 24px; /* Direct emoji size */
  }
  .action-btn .label {
    font-size: 9px;
  }
}

/* Smaller phones */
@media (max-width: 380px) {
  .dpad-btn {
    width: 54px;
    height: 54px;
    font-size: 24px;
  }
  .action-btn {
    width: 58px;
    height: 58px;
    font-size: 24px; /* Direct emoji size */
  }
}
</style>
</head>
<body>
<canvas id="game" width="320" height="180"></canvas>
<!-- Mobile Controls: Retro Gamepad Layout -->
<div class="mobile-controls">
  <!-- Left: D-Pad Movement -->
  <div class="dpad-container">
    <button class="dpad-btn dpad-whistle" data-key="w" aria-label="Whistle">üéµ</button>
    <button class="dpad-btn dpad-outfit" data-key="q" aria-label="Change Outfit">üëï</button>
    <button class="dpad-btn dpad-left" data-key="a" aria-label="Move Left">‚Üê</button>
    <button class="dpad-btn dpad-right" data-key="d" aria-label="Move Right">‚Üí</button>
  </div>
  
  <!-- Right: Action Buttons -->
  <div class="action-cluster">
    <div class="action-row">
      <button class="action-btn" data-key="m" aria-label="Moon Previous">üåï</button>
      <button class="action-btn" data-key="n" aria-label="Moon Next">üåô</button>
    </div>
    <div class="action-row">
      <button class="action-btn primary" data-key="s" aria-label="Shooting Star">‚≠ê</button>
      <button class="action-btn primary" data-key="r" aria-label="Toggle Rain">üåßÔ∏è</button>
    </div>
  </div>
</div>
<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
ctx.imageSmoothingEnabled = false;

const W = 320, H = 180;

// ===== DYNAMIC CANVAS RESIZE (CRISP PIXELS, FULLSCREEN ON DESKTOP/MOBILE) =====
function resizeCanvas() {
  const isMobile = window.innerWidth <= 1024;
  const isFullscreen = !!(
    document.fullscreenElement ||
    document.webkitFullscreenElement ||
    document.mozFullScreenElement
  );
  
  if (isMobile || isFullscreen) {
    const scaleX = window.innerWidth / W;
    const scaleY = window.innerHeight / H;
    const scale = Math.floor(Math.min(scaleX, scaleY, 8));
    canvas.style.width = `${W * scale}px`;
    canvas.style.height = `${H * scale}px`;
  } else {
    const FIXED_SCALE = 3; // ‚Üê Adjust this to your preference!
    canvas.style.width = `${W * FIXED_SCALE}px`;
    canvas.style.height = `${H * FIXED_SCALE}px`;
  }
  canvas.style.maxWidth = '100vw';
  canvas.style.maxHeight = '100vh';
}

window.addEventListener('resize', resizeCanvas);
window.addEventListener('orientationchange', () => setTimeout(resizeCanvas, 200));
document.addEventListener('fullscreenchange', resizeCanvas);
document.addEventListener('webkitfullscreenchange', resizeCanvas);
document.addEventListener('mozfullscreenchange', resizeCanvas);
resizeCanvas(); // Initial call

// ===== MOBILE CONTROLS WITH HAPTIC FEEDBACK & DOUBLE-TAP-TO-RUN =====
function initMobileControls() {
  // Track double-tap timing for movement buttons
  const doubleTapTimers = {};
  const doubleTapDelay = 300; // ms between taps to register as double-tap
  
  document.querySelectorAll('[data-key]').forEach(btn => {
    const key = btn.dataset.key;
    const isMovementKey = (key === 'a' || key === 'd'); // Only arrows get double-tap
    
    let tapCount = 0;
    let tapTimer = null;
    let isRunning = false;
    
    const press = (e) => {
      e.preventDefault();
      e.stopPropagation();
      
      // Visual feedback
      btn.classList.add('pressed');
      
      // Haptic feedback (10ms vibration)
      if ('vibrate' in navigator) {
        navigator.vibrate(10);
      }
      
      // Double-tap detection for movement keys
      if (isMovementKey) {
        tapCount++;
        
        // Clear existing timer
        if (tapTimer) {
          clearTimeout(tapTimer);
        }
        
        // If second tap within delay window = RUN MODE
        if (tapCount === 2) {
          isRunning = true;
          tapCount = 0; // Reset for next sequence
          
          // Dispatch Shift+Key (for running)
          const evDown = new KeyboardEvent('keydown', {
            key: key,
            code: `Key${key.toUpperCase()}`,
            shiftKey: true, // SHIFT for running!
            bubbles: true,
            cancelable: true
          });
          document.dispatchEvent(evDown);
          
          if (DEBUG) console.log(`üèÉ Running mode activated: ${key.toUpperCase()}`);
        } else {
          // First tap or timeout reset = WALK MODE
          isRunning = false;
          
          // Dispatch normal key (walking)
          const evDown = new KeyboardEvent('keydown', {
            key: key,
            code: `Key${key.toUpperCase()}`,
            bubbles: true,
            cancelable: true
          });
          document.dispatchEvent(evDown);
          
          // Set timer to reset tap count if no second tap
          tapTimer = setTimeout(() => {
            tapCount = 0;
          }, doubleTapDelay);
        }
      } else {
        // Non-movement keys: normal behavior
        const evDown = new KeyboardEvent('keydown', {
          key: key,
          code: key === ' ' ? 'Space' : `Key${key.toUpperCase()}`,
          bubbles: true,
          cancelable: true
        });
        document.dispatchEvent(evDown);
      }
    };
    
    const release = (e) => {
      e.preventDefault();
      e.stopPropagation();
      
      // Remove visual feedback
      btn.classList.remove('pressed');
      
      // Dispatch key release (with shift if running)
      if (isMovementKey && isRunning) {
        const evUp = new KeyboardEvent('keyup', {
          key: key,
          code: `Key${key.toUpperCase()}`,
          shiftKey: true,
          bubbles: true,
          cancelable: true
        });
        document.dispatchEvent(evUp);
        
        // Keep running state until next press cycle
      } else {
        const evUp = new KeyboardEvent('keyup', {
          key: key,
          code: key === ' ' ? 'Space' : `Key${key.toUpperCase()}`,
          bubbles: true,
          cancelable: true
        });
        document.dispatchEvent(evUp);
      }
    };

    // Touch events (mobile)
    btn.addEventListener('touchstart', press, { passive: false });
    btn.addEventListener('touchend', release, { passive: false });
    btn.addEventListener('touchcancel', release, { passive: false });

    // Mouse events (desktop testing)
    btn.addEventListener('mousedown', press);
    btn.addEventListener('mouseup', release);
    btn.addEventListener('mouseleave', release);

    // Prevent context menu
    btn.addEventListener('contextmenu', e => e.preventDefault());
  });
  
  if (DEBUG) console.log('üéÆ Mobile controls initialized with double-tap-to-run');
}

// Init after DOM loads
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initMobileControls);
} else {
  initMobileControls();
}


// ===== DEBUG CONFIGURATION =====
const DEBUG = false; // Production mode (issue resolved)

// ===== GAME CONSTANTS =====
const SIDEWALK_Y = 125;
const SIDEWALK_HEIGHT = 10;
const SIDEWALK_BOTTOM_Y = SIDEWALK_Y + SIDEWALK_HEIGHT; // 135
const ROAD_BOTTOM_Y = 175;
const ROAD_TOP_Y_MIN = SIDEWALK_BOTTOM_Y + 1; // below sidewalk (136)
const PUDDLE_COUNT = 35;

// ===== CACHED GRADIENTS (performance optimization) =====
let CACHED_GRADIENTS = null;

function initGradients() {
  if (CACHED_GRADIENTS) return; // Already initialized
  
  CACHED_GRADIENTS = {
    titleScreen: null,
    vignetteBase: null
  };
  
  // Title screen gradient
  const titleGrad = ctx.createLinearGradient(0, 0, 0, H);
  titleGrad.addColorStop(0, 'rgba(10, 10, 50, 0.4)');
  titleGrad.addColorStop(1, 'rgba(50, 50, 90, 0.6)');
  CACHED_GRADIENTS.titleScreen = titleGrad;
  
  // Vignette gradient (base - can be modified with color)
  const vigGrad = ctx.createRadialGradient(W/2, H/2, 0, W/2, H/2, Math.max(W,H)/1.2);
  vigGrad.addColorStop(0, 'rgba(0,0,0,0)');
  vigGrad.addColorStop(1, 'rgba(0,0,0,0.3)'); // Base alpha
  CACHED_GRADIENTS.vignetteBase = vigGrad;
  
  if (DEBUG) console.log('üé® Gradients cached for performance');
}

// ===== PUDDLE INITIALIZATION =====
function initPuddles() {
  if (DEBUG) console.log("Starting puddle initialization...");
  const ROAD_START_X = -200;  // Start puddles further back (player starts at 0)
  const ROAD_END_X = DOCK_CONFIG.startX - 80;  // Stop well before dock
  
  if (DEBUG) console.log(`Puddle spread: ${ROAD_START_X} to ${ROAD_END_X}, Y: ${ROAD_TOP_Y_MIN} to ${ROAD_BOTTOM_Y}`);

  // Helper function to check if two puddles overlap
  function puddlesOverlap(p1, p2) {
    return !(p1.x + p1.w < p2.x || // p1 is left of p2
             p2.x + p2.w < p1.x || // p2 is left of p1
             p1.y + p1.h < p2.y || // p1 is above p2
             p2.y + p2.h < p1.y);  // p2 is above p1
  }

  puddles = []; // Clear any existing puddles

  for (let i = 0; i < PUDDLE_COUNT; i++) {
    let attempts = 0;
    let validPuddle = false;
    let x, y, w, h, baseAlpha;
    
    while (!validPuddle && attempts < 50) { // Try up to 50 times
      // Cat-aware spawning: puddles spawn below cat (Y=145-175)
      const CAT_Y = 145; // Cat's Y position
      
      x = ROAD_START_X + detRandom() * (ROAD_END_X - ROAD_START_X);
      
      // Weighted distribution: 40% at junction, 60% across road
      const JUNCTION_Y = SIDEWALK_BOTTOM_Y + 2; // Y = 137 (2px below sidewalk)
      if (detRandom() < 0.4) {
        // 40% chance: spawn at junction with tiny variation (137-140)
        y = JUNCTION_Y + detRandom() * 3;
      } else {
        // 60% chance: normal road distribution (145-175)
        y = CAT_Y + detRandom() * (ROAD_BOTTOM_Y - CAT_Y);
      }
      
      w = 12 + detRandom() * 20;  // 12-32px (varied sizes)
      h = 6 + detRandom() * 14;   // 6-20px (deeper puddles)
      baseAlpha = 0.12 + detRandom() * 0.10;  // 0.12-0.22 (slightly more visible)
      
      // Check for overlaps with existing puddles
      validPuddle = true;
      for (let j = 0; j < puddles.length; j++) {
        if (puddlesOverlap({x, y, w, h}, puddles[j])) {
          validPuddle = false;
          break;
        }
      }
      
      attempts++;
    }
    
    if (validPuddle) {
      puddles.push({x, y, w, h, baseAlpha, seed: detRandom() * 1000});
      
      // Debug first 5 puddles
      if (i < 5 && DEBUG) {
        if (DEBUG) console.log(`Puddle ${i}: x=${x.toFixed(1)}, y=${y.toFixed(1)}, w=${w.toFixed(1)}, h=${h.toFixed(1)}`);
      }
    }
  }
  
  // if (DEBUG) console.log(`Created ${puddles.length} puddles`);
}

// ===== SEEDED PRNG FOR DETERMINISM =====
function mulberry32(seed) {
  return function() {
    var t = seed += 0x6D2B79F5;
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  }
}
const WORLD_SEED = 12345;
const rand = mulberry32(WORLD_SEED);

function detRandom() {
  return rand();
}

// ===== EVENT QUEUE SYSTEM =====
let eventQueue = [];

function scheduleEvent(triggerX, callback, once = true) {
    eventQueue.push({
        triggerX,
        callback,
        once,
        fired: false,
        id: Date.now() + Math.random()
    });
}

function updateEvents(playerX) {
    for (let i = eventQueue.length - 1; i >= 0; i--) {
        const e = eventQueue[i];
        if ((!e.fired || !e.once) && playerX >= e.triggerX) {
            e.callback();
            e.fired = true;
            if (e.once) {
                eventQueue.splice(i, 1);
            }
        }
    }
}

// ===== MOON SYSTEM =====
const MOON_COLORS = {
  0: { // NEW
    base: '#bfc3d0',                     // moon surface
    halo: 'rgba(120,150,255,0.25)',      // cold bioluminescence
    wash: 'rgba(20,30,60,0.03)'
  },
  1: { // WAXING_CRESCENT
    base: '#d4d6e0',
    halo: 'rgba(180,120,255,0.30)',
    wash: 'rgba(50,30,80,0.04)'
  },
  2: { // FIRST_QUARTER
    base: '#e5e6ea',
    halo: 'rgba(140,200,255,0.25)',
    wash: 'rgba(40,60,90,0.03)'
  },
  3: { // WAXING_GIBBOUS
    base: '#e8e9ec',
    halo: 'rgba(160,220,255,0.28)',
    wash: 'rgba(45,65,95,0.035)'
  },
  4: { // FULL
    base: '#f5f5f5',
    halo: 'rgba(200,240,255,0.35)',
    wash: 'rgba(80,100,140,0.05)'
  },
  5: { // WANING_GIBBOUS
    base: '#e0e2e8',
    halo: 'rgba(120,180,255,0.22)',
    wash: 'rgba(35,45,85,0.04)'
  },
  6: { // LAST_QUARTER
    base: '#d8dae2',
    halo: 'rgba(100,160,255,0.20)',
    wash: 'rgba(30,40,80,0.035)'
  },
  7: { // WANING_CRESCENT
    base: '#d0d4dc',
    halo: 'rgba(90,140,255,0.18)',
    wash: 'rgba(25,35,75,0.03)'
  }
};

let moonVisible = false;

// Moon position globals for cosmic rendering
let moonX = 212;
let moonY = 24;
let moonRadius = 8.5;

// Moon face state for expressions
let moonFace = null; // 'angry' | 'happy'
let moonFaceTimer = 0;
const MOON_FACE_DURATION = 240; // ~4 seconds

// Smooth atmospheric transitions
let moonBlend = 0;
let lastMoonPhase; // Will be initialized after moonPhase

// New moon evil wink secret
let newMoonEvilWinkActive = false;
let newMoonEvilWinkTimer = 0;
let newMoonEvilWinkFrame = 0;  // 0 = both eyes open (glaring), 1 = right eye narrowed/slit (evil wink)

// Full moon crater smile/wink secret
let fullMoonSmileActive = false;
let fullMoonSmileTimer = 0;
let fullMoonSmileFrame = 0;  // 0 = normal, 1 = smile appears, 2 = wink (one eye closed)

// Phase constants (real lunar progression)
const MOON_PHASES = {
  NEW: 0,
  WAXING_CRESCENT: 1,
  FIRST_QUARTER: 2,
  WAXING_GIBBOUS: 3,
  FULL: 4,
  WANING_GIBBOUS: 5,
  LAST_QUARTER: 6,
  WANING_CRESCENT: 7,
};

let moonPhase = MOON_PHASES.FULL;
const MOON_PHASE_COUNT = 8;
const WATER_LINE_Y = 130;

// Initialize lastMoonPhase after moonPhase is declared
lastMoonPhase = moonPhase;

// Phase-aware reflection widths (corrected for 8 phases)
const PHASE_REFLECTION_WIDTH = [
  0, // new
  2, // waxing crescent
  3, // first quarter
  4, // waxing gibbous
  5, // full
  4, // waning gibbous
  3, // last quarter
  2, // waning crescent
];

// Moon sparkle system
const MOON_SPARKLE_COLOR = "rgba(255,255,255,0.18)";
let moonSparkleLife = 0;

// Player reflection state (conditional on moonlight)
let moonReflectionAlpha = 0;

// üåï OFFSCREEN MOON BUFFER (THE FIX)
const moonCanvas = document.createElement("canvas");
moonCanvas.width = 17;
moonCanvas.height = 17;
const moonCtx = moonCanvas.getContext("2d");

// üåï HAND-CRAFTED 17√ó17 PIXEL CIRCLE (PIXEL-ART CORRECT)
const MOON_PIXELS = [
  ".....#####.....",
  "...#########...",
  "..###########..",
  ".#############.",
  ".#############.",
  "###############",
  "###############",
  "###############",
  "###############",
  "###############",
  "###############",
  ".#############.",
  ".#############.",
  "..###########..",
  "...#########...",
  ".....#####.....",
];

// Frame counter for animations
let frameCount = 0;

// ===== OPTIMIZATION CONFIG =====
const OPTIMIZATION = {
    heavyUpdateThreshold: 0.4
};

// ===== NIGHT EFFECTS =====
const NIGHT_EFFECTS = {
    fogAlpha: 0,
    silhouetteAlpha: 0,
    windowGlowMultiplier: 1.0,
    distantHills: []
};

for(let i = 0; i < 5; i++) {
    NIGHT_EFFECTS.distantHills.push({
        x: i * 80,
        height: 15 + detRandom() * 10,
        width: 40 + detRandom() * 30,
        color: `hsl(240, 30%, ${15 + i * 3}%)`
    });
}

// ===== LEFT FADE BOUNDARIES =====
const LEFT_FADE_START = -520; // Moved another 80 pixels further left
const LEFT_FADE_END = -660;   // Moved another 80 pixels further left

// ===== DOCK & WATER CONFIGURATION =====
const DOCK_CONFIG = {
    // Dock attaches to the last pole of the SECOND set
    startX: 0, // Will be calculated in initDock()
    length: 180,
    poleSpacing: 24,
    dockPoleWidth: 4,
    plankHeight: 4,
    waterLevel: 130, // Same Y as road (groundY)
    waterHeight: 50,
    waterRippleSpeed: 0.02,
    waterRippleAmplitude: 1.5,
    moonX: 60,
    moonY: 40,
    moonReflectionWidth: 16,
    moonReflectionHeight: 60,
    endLightRadius: 4,
    endLightHaloRadius: 30,
    dockPoleColor: "#3f3a36",     // weathered, cool brown
    dockPlankColor: "#5b5668",   // violet-gray wood
    waterColorBase: "#2b3a5c",
    waterColorLight: "#4a5a7d",
    moonReflectionColor: "rgba(255,255,220,0.3)"
};

// Dock poles and planks
let dockPoles = [];
let waterRippleOffset = 0;

// Static puddles at sidewalk-road junction (seeded, permanent)
let puddles = [];

// We need to track where the second set of poles ends
let secondLampPositions = [];

function initDock() {
    // Calculate second lamp positions first
    const lampPositions = [180, 340, 500, 660, 820];
    const firstSetEndX = lampPositions[lampPositions.length - 1];
    const offset = 480;
    const lampSpacing = 160;
    
    // Create second set (3 lamps only)
    secondLampPositions = [];
    for (let i = 0; i < 3; i++) {
        secondLampPositions.push(firstSetEndX + offset + lampSpacing * i);
    }
    
    // Dock attaches 160px AFTER the last pole of the second set
    const lastSecondSetPoleX = secondLampPositions[secondLampPositions.length - 1];
    const DOCK_OFFSET = 160; // visual breathing room
    DOCK_CONFIG.startX = lastSecondSetPoleX + DOCK_OFFSET;
    
    // console.log("Dock starts at:", DOCK_CONFIG.startX, `(160px after last pole at ${lastSecondSetPoleX})`);
    // console.log("Second set poles:", secondLampPositions);
    
    // Create dock poles
    dockPoles = [];
    
    for (
        let x = DOCK_CONFIG.startX;
        x <= DOCK_CONFIG.startX + DOCK_CONFIG.length;
        x += DOCK_CONFIG.poleSpacing
    ) {
        dockPoles.push({
            x,
            y: DOCK_CONFIG.waterLevel,
            height: 32 + Math.floor(detRandom() * 4),
            baseX: x,
            baseY: DOCK_CONFIG.waterLevel,
            swayPhase: detRandom() * Math.PI * 2,
            swaySpeed: 0.01 + detRandom() * 0.02,
            swayAmplitude: 0.2 + detRandom() * 0.3
        });
    }
}

// ‚îÄ‚îÄ‚îÄ PLAYER STATE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let keys = {};
let playerX = 40;
let twilight = 0;
let moving = false;
let stepTimer = 0;
let facingRight = true; // Player direction for whistle mouth position
let stepFrame = 0;

// Player object with outfit support
const player = {
  x: 60,
  y: 120,
  topColor: "#C7D3D4", // default outfit top
  bottomColor: "#A6B7C5", // default outfit bottom
  pattern: null
};

// ‚îÄ‚îÄ‚îÄ WHISTLE SYSTEM ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let whistling = false;
let whistleDuration = 0;
const WHISTLE_DURATION = 15; // frames to show mouth dot

// üå† Player-triggered cinematic shooting stars
let playerShootingStars = [];

// New rain system globals - UNIFIED SMOOTH RAIN
let rainLevel = 0;        // 0‚Äì3 (off ‚Üí heavy)
let rainTarget = 0;
let rainIntensity = 0;   // smoothed 0‚Äì1
let rainDrops = [];

// ===== RAIN AUDIO SYSTEM =====
let audioCtx = null;
let rainAmbientSource = null;
let rainLPF = null;
let rainGain = null;
let whiteNoiseBuffer = null;
let lastRainUpdate = 0;

// Optional master rain volume control (console: masterRainVol = 0.5 for half volume)
let masterRainVol = 1.0;

function initRainAudio() {
  if (audioCtx) return; // Already initialized

  // if (DEBUG) console.log('üåßÔ∏è Initializing rain audio system...');
  audioCtx = window.audioCtx || new (window.AudioContext || window.webkitAudioContext)();
  if (audioCtx.state === 'suspended') audioCtx.resume();
  // if (DEBUG) console.log(`üåßÔ∏è AudioContext state: ${audioCtx.state}`);

  // ===== SEAMLESS AMBIENT PINK NOISE (10s loop - imperceptible cycles) =====
  const bufferLength = audioCtx.sampleRate * 10; // 10s - long enough to feel infinite
  const buffer = audioCtx.createBuffer(1, bufferLength, audioCtx.sampleRate);
  const data = buffer.getChannelData(0);

  // Voss-McCartney pink noise generator (soothing 1/f spectrum for rain)
  let b0 = b1 = b2 = b3 = b4 = b5 = b6 = 0;
  for (let i = 0; i < bufferLength; i++) {
    const white = Math.random() * 2 - 1;
    b0 = 0.99886 * b0 + white * 0.0555179;
    b1 = 0.99332 * b1 + white * 0.0750759;
    b2 = 0.96900 * b2 + white * 0.1538520;
    b3 = 0.86650 * b3 + white * 0.3104856;
    b4 = 0.55000 * b4 + white * 0.5329522;
    b5 = -0.7616 * b5 - white * 0.0168980;
    data[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;
    data[i] *= 0.11; // Normalize volume
    b6 = white * 0.115926;
  }

  rainAmbientSource = audioCtx.createBufferSource();
  rainAmbientSource.buffer = buffer;
  rainAmbientSource.loop = true;
  rainAmbientSource.loopStart = 0;
  rainAmbientSource.loopEnd = buffer.duration;

  // Heavy low-pass filter: MUFFLED/soothing (400-800Hz range)
  rainLPF = audioCtx.createBiquadFilter();
  rainLPF.type = 'lowpass';
  rainLPF.frequency.value = 600; // Soft/muffled rain wash
  rainLPF.Q.value = 0.7; // Gentle rolloff

  // Master gain for smooth intensity control
  rainGain = audioCtx.createGain();
  rainGain.gain.value = 0; // Start silent

  // Connect: source -> LPF -> gain -> speakers
  rainAmbientSource.connect(rainLPF);
  rainLPF.connect(rainGain);
  rainGain.connect(audioCtx.destination);

  // Start ambient loop immediately (muted)
  rainAmbientSource.start();

  // ===== PRE-GENERATE WHITE NOISE BUFFER FOR DROPS =====
  const dropBufferLength = audioCtx.sampleRate * 0.2; // 200ms drops
  whiteNoiseBuffer = audioCtx.createBuffer(1, dropBufferLength, audioCtx.sampleRate);
  const dropData = whiteNoiseBuffer.getChannelData(0);
  for (let i = 0; i < dropBufferLength; i++) {
    dropData[i] = Math.random() * 2 - 1;
    dropData[i] *= 0.3; // Pre-scale for softness
  }

  if (DEBUG) console.log('üåßÔ∏è Rain audio initialized: Seamless pink ambient + muffled drops');
}

function playRainDrop(intensity) {
  if (!audioCtx) return;

  const source = audioCtx.createBufferSource();
  source.buffer = whiteNoiseBuffer;

  // Per-drop LPF: Less muffled (400-900Hz) = clearer "tap" sounds
  const dropLPF = audioCtx.createBiquadFilter();
  dropLPF.type = 'lowpass';
  dropLPF.frequency.value = 400 + Math.random() * 500; // Higher range = more audible sparkle
  dropLPF.Q.value = 0.6; // Slightly sharper

  // BOOSTED Soft envelope: Quick attack, medium decay (doubled peak volume)
  const dropGain = audioCtx.createGain();
  const now = audioCtx.currentTime;
  dropGain.gain.setValueAtTime(0, now);
  dropGain.gain.linearRampToValueAtTime(0.08 * intensity * masterRainVol, now + 0.005); // Apply master volume
  dropGain.gain.exponentialRampToValueAtTime(0.004, now + 0.15); // Slightly longer tail for "pat"

  // Connect & play
  source.connect(dropLPF);
  dropLPF.connect(dropGain);
  dropGain.connect(audioCtx.destination);

  source.start(now);
  source.stop(now + 0.15);
}

function updateRainAudio(intensity, dt) {
  // Fallback initialization if system wasn't set up
  if (!rainGain && intensity > 0) {
    if (DEBUG) console.log('üîß Rain audio not initialized, initializing now...');
    initRainAudio();
  }
  
  if (!rainGain) return;

  // HALVED ambient volume: Softer/soothing wash (0.12 ‚Üí 0.06)
  const targetAmbientVol = intensity * 0.06 * masterRainVol; // Apply master volume
  rainGain.gain.setTargetAtTime(targetAmbientVol, audioCtx.currentTime, 0.15);

  // Subtle breathing modulation (unchanged - cozy swell)
  const breathe = 0.92 + 0.08 * Math.sin(Date.now() * 0.0005);
  rainGain.gain.setTargetAtTime(targetAmbientVol * breathe, audioCtx.currentTime + 0.1, 0.15);

  // Dynamic LPF: Slightly higher base (500Hz) for softer-but-clearer tone
  rainLPF.frequency.setTargetAtTime(500 + intensity * 400, audioCtx.currentTime, 0.2);

  // MORE drops: Slightly higher rate (0-25/sec) for fuller sound
  const dropChance = intensity * 25 * dt;
  if (Math.random() < dropChance) {
    playRainDrop(intensity);
  }
}

function stopRain() {
  if (!rainGain) return;
  rainGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.3); // Smooth 300ms fadeout
}

// Test function for debugging rain audio
function testRainAudio() {
  // if (DEBUG) console.log('üß™ Testing rain audio system...');
  // if (DEBUG) console.log(`audioCtx: ${audioCtx ? 'exists' : 'null'}`);
  // if (DEBUG) console.log(`rainGain: ${rainGain ? 'exists' : 'null'}`);
  // if (DEBUG) console.log(`rainAmbientSource: ${rainAmbientSource ? 'exists' : 'null'}`);
  if (DEBUG) console.log(`rainLPF: ${rainLPF ? 'exists' : 'null'}`);
  if (DEBUG) console.log(`whiteNoiseBuffer: ${whiteNoiseBuffer ? 'exists' : 'null'}`);
  if (DEBUG) console.log(`masterRainVol: ${masterRainVol} (change with: masterRainVol = 0.5)`);
  
  if (audioCtx) {
    if (DEBUG) console.log(`AudioContext state: ${audioCtx.state}`);
    if (DEBUG) console.log(`Sample rate: ${audioCtx.sampleRate}`);
  }
  
  if (rainGain) {
    if (DEBUG) console.log(`Current rain gain: ${rainGain.gain.value}`);
  }
  
  // Test a single drop
  if (audioCtx && whiteNoiseBuffer) {
    if (DEBUG) console.log('üß™ Playing test drop...');
    playRainDrop(1.0);
  }
}

// Manual initialization function - call this if audio doesn't start
function manualInitRainAudio() {
  if (DEBUG) console.log('üîß Manual rain audio initialization...');
  initRainAudio();
}

// ===== TITLE SCREEN SYSTEM =====
// New globals (add with other lets)
let gameState = 'title';  // 'title' | 'playing'
let titleFadeAlpha = 0;
let fadingToGame = false;

function playWhistle(pitchMult = 1.0) {
    // console.log(`Whistle played! Pitch multiplier: ${pitchMult}`);
  const audioCtx = window.audioCtx || new (window.AudioContext || window.webkitAudioContext)();
  window.audioCtx = audioCtx;
  
  // Resume AudioContext if suspended (browser security)
  if (audioCtx.state === 'suspended') {
    audioCtx.resume();
    // console.log('AudioContext resumed for whistle');
  }
  
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  
  // Random note from a pleasant scale (pentatonic-ish)
  const notes = [523.25, 587.33, 659.25, 783.99, 880.00]; // C5, D5, E5, G5, A5
  const randomNote = notes[Math.floor(Math.random() * notes.length)] * pitchMult;
  
  osc.type = 'sine'; // soft sine wave for whistle
  osc.frequency.setValueAtTime(randomNote, audioCtx.currentTime);
  
  // Gentle volume envelope - muffled and soft
  gain.gain.setValueAtTime(0, audioCtx.currentTime);
  gain.gain.linearRampToValueAtTime(0.03, audioCtx.currentTime + 0.05);
  gain.gain.linearRampToValueAtTime(0.02, audioCtx.currentTime + 0.15);
  gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.25);
  
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  
  osc.start();
  osc.stop(audioCtx.currentTime + 0.25);
  
  // Trigger visual whistle indicator
  whistling = true;
  whistleDuration = WHISTLE_DURATION;
    // console.log(`Whistling state set to true. Duration: ${whistleDuration}`);
}

// ‚îÄ‚îÄ‚îÄ DOCK LAMP SPARKLE SYSTEM ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
class DockLampSparkle {
    constructor(x, y, targetScreenX = null, r = 200, g = 255, b = 180, enhancedFall = false) {
        this.x = x;
        this.y = y;
        this.targetScreenX = targetScreenX;
        this.r = r;
        this.g = g;
        this.b = b;
        this.enhancedFall = enhancedFall;
        this.age = 0;
        this.lifetime = 50 + Math.random() * 30; // short-lived
        this.size = 0.5 + Math.random() * 1.0;  // tiny sparkles
        this.alpha = 0.05 + Math.random() * 0.1; // much more see-through
        this.vx = (Math.random() - 0.5) * 0.02; // very tight cone
        this.vy = 0.1 + Math.random() * 0.05;   // slow downward drift
        if (enhancedFall) {
            this.vy += 0.12; // Extra downward velocity for whistle-triggered particles
        }
        
        // Cache base color string to avoid concatenation in draw loop
        this.baseColor = `rgba(${this.r},${this.g},${this.b},`;
    }

    update() {
        this.age++;
        
        if (this.targetScreenX !== null) {
            // Shell mode: lerp to player feet (screenX=62, parallax-adjusted world pos)
            const pf = 0.7;
            const tx = this.targetScreenX + playerX * pf;
            const ty = 130;
            const dx = tx - this.x;
            const dy = ty - this.y;
            
            // Move towards target with easing
            this.x += dx * 0.08;
            this.y += dy * 0.08;
            
            // Fade in as approaching
            if (this.age < 20) {
                this.alpha = Math.min(0.8, this.alpha + 0.02);
            }
        } else {
            // Normal fall: gentle downward drift with slight wobble
            this.x += this.vx;
            this.y += this.vy;
            
            // Fade out over lifetime
            if (this.age > 30) {
                this.alpha *= 0.92;
            }
        }
        
        // Add subtle flicker
        this.alpha = 0.05 + 0.1 * Math.sin((this.age / this.lifetime) * Math.PI); // subtle flicker
        
        // Fade as they fall/settle
        this.alpha *= 0.996;
        if (this.alpha < 0.02) this.alpha = 0.02;
        
        if (this.size < 0.3) this.size = 0.3;
        if (this.size > 1.2) this.size = 1.2;
    }

    draw(ctx) {
        const screenX = ~~(this.x - playerX * 0.7); // Apply same parallax as dock
        const screenY = ~~this.y;
        ctx.fillStyle = `rgba(${this.r},${this.g},${this.b},${this.alpha})`;
        ctx.fillRect(screenX, screenY, this.size, this.size);
    }

    isAlive() {
        return this.age < this.lifetime;
    }
}

// Global dock lamp sparkles storage
let dockLampSparkles = [];
let shellPileCount = 0;

function updateDockLampSparkles() {
    // Calculate sparkle spawn rate
    let sparkleChance = 0.3; // Default rate
    
    // Debug logging for dock lamp trigger
    if (whistling && dockPoles.length > 0) {
        const dockEndX = DOCK_CONFIG.startX + DOCK_CONFIG.length;
        const playerNearDockEnd = Math.abs(playerX - dockEndX) < 800; // Within 800px of dock end (matches seagull area)
        const distanceToDockEnd = Math.abs(playerX - dockEndX);
        
        if (playerNearDockEnd) {
            sparkleChance = 0.8; // Much higher spawn rate when whistling
        }
    }
    
    // Spawn new tiny sparkles occasionally
    if (Math.random() < sparkleChance) {
        // Calculate exact dock lamp light position
        const lastDockPole = dockPoles[dockPoles.length - 1];
        if (lastDockPole) {
            const lampBaseY = lastDockPole.y - lastDockPole.height;
            const scale = 0.85;
            const armLength = Math.floor(6 * scale);
            const poleHeight = Math.floor(34 * scale);
            const poleTop = lampBaseY + 2 - poleHeight;
            
            // Exact lamp light position (matching drawPoleLamp) + 2 pixels down
            const dockLampX = lastDockPole.x + armLength + 1;
            const dockLampY = poleTop + 7 + 2; // 2 pixels lower than the light
            
            dockLampSparkles.push(new DockLampSparkle(dockLampX, dockLampY, null, 200, 255, 180, sparkleChance > 0.3)); // Enhanced fall for whistle-triggered sparkles
        }
    }

    // Update all sparkles
    dockLampSparkles = dockLampSparkles.filter(p => {
        p.update();
        return p.isAlive();
    });
}

function drawDockLampSparkles(ctx) {
    dockLampSparkles.forEach(p => p.draw(ctx));
}

function spawnShellSparkles(wx, wy, count = 1) {
  for (let i = 0; i < count; i++) {
    const ox = (detRandom() - 0.5) * 8;
    const oy = detRandom() * 3;
    dockLampSparkles.push(new DockLampSparkle(wx + ox, wy + oy, 62, 255, 215, 0));
  }
}

// ‚îÄ‚îÄ‚îÄ LAMP SPARKLE PARTICLE SYSTEM ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
class LampParticle {
  constructor(lampX, lampY, maxRadius) {
    this.lampX = lampX;
    this.lampY = lampY;
    this.maxRadius = maxRadius;
    this.reset();
  }

  reset() {
    // Start somewhere under the lamp within a circular area
    const angle = Math.random() * Math.PI * 2;
    const radius = Math.random() * this.maxRadius;
    this.baseX = this.lampX + Math.cos(angle) * radius;
    // New: particles start slightly above the lamp (2 pixels above)
    this.baseY = this.lampY - 2;

    // tiny initial size and alpha
    this.size = Math.random() * 1.2 + 0.5;
    this.alpha = Math.random() * 0.4 + 0.1;

    // brightness multiplier, can increase at night
    this.brightness = Math.random() * 0.6 + 0.4;

    // movement offsets
    this.offsetX = 0;
    this.offsetY = 0;
    // New: tighter cone for horizontal spread
    let coneWidth = 0.05; // smaller = tighter cone
    this.vx = (Math.random() - 0.5) * coneWidth;
    this.vy = Math.random() * 0.15; // positive ‚Üí moves down

    // flicker speed
    this.flickerSpeed = Math.random() * 0.05 + 0.02;
    
    // Add age/lifetime for cone effect
    this.age = 0;
    this.lifetime = 100 + Math.random() * 100; // 100-200 frames lifetime
    
    // Cache base color string to avoid concatenation in draw loop
    this.baseColor = 'rgba(255,255,210,';
  }

  update(nightFactor = 1) {
    // Age the particle
    this.age++;
    
    // Calculate cone factor (1.0 at start, 0.0 at end)
    const coneFactor = 1 - (this.age / this.lifetime);
    
    // move particle with cone effect
    this.offsetX += this.vx * coneFactor; // Less horizontal movement as particle ages
    this.offsetY += this.vy;
    
    // Add subtle gravity
    this.vy += 0.002; // subtle gravity, makes cone look natural

    // gently wrap around circular lamp area
    const dx = this.baseX + this.offsetX - this.lampX;
    const dy = this.baseY + this.offsetY - this.lampY;
    const distance = Math.sqrt(dx*dx + dy*dy);
    if (distance > this.maxRadius) {
      this.offsetX *= 0.8;
      this.offsetY *= 0.8;
    }

    // dynamic flicker in alpha and size
    this.alpha += (Math.random() - 0.5) * this.flickerSpeed;
    this.size += (Math.random() - 0.5) * 0.1;

    // Optional: slowly fade as they fall
    this.alpha *= 0.995;

    // constrain values
    if (this.alpha < 0.05) this.alpha = 0.05;
    if (this.alpha > 0.6) this.alpha = 0.6;
    if (this.size < 0.4) this.size = 0.4;
    if (this.size > 1.5) this.size = 1.5;

    // adjust brightness slightly based on night
    this.currentBrightness = this.brightness * nightFactor;
    
    // Reset if particle gets too old
    if (this.age >= this.lifetime) {
      this.reset();
    }
  }

  draw(ctx) {
    const worldX = this.baseX + this.offsetX;
    const worldY = this.baseY + this.offsetY;
    const screenX = ~~(worldX - playerX * 0.7); // Apply same parallax as lamps
    const screenY = ~~worldY;
    
    // Prevent drawing exactly at (0,0) to avoid corner pixel artifact
    if (screenX === 0 && screenY === 0) return;
    
    ctx.fillStyle = this.baseColor + (this.alpha * this.currentBrightness) + ')';
    ctx.fillRect(screenX, screenY, this.size, this.size);
  }
}

// Global particle storage
const lampParticles = [];

// Initialize particles for all lamps
function createLampParticles(lamps) {
  // console.log("Creating lamp sparkles for", lamps.length, "lamps");
  lamps.forEach(lamp => {
    for (let i = 0; i < 30; i++) { // 30 subtle sparkles per lamp
      lampParticles.push(new LampParticle(lamp.x, lamp.y, lamp.radius));
    }
  });
  // console.log("Total lamp particles created:", lampParticles.length);
}

// Update & draw loop
function updateLampParticles(nightFactor) {
  lampParticles.forEach(p => p.update(nightFactor));
}

function drawLampParticles(ctx) {
  lampParticles.forEach(p => p.draw(ctx));
}

// ‚îÄ‚îÄ‚îÄ PLAYER OUTFIT SYSTEM ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let currentOutfitIndex = 0;

const outfits = [
  { top: "#C7D3D4", bottom: "#A6B7C5" },
  { top: "#F4D8C2", bottom: "#D9BBA6" },
  { top: "#D7E0F1", bottom: "#B8C8D9" },
  { top: "#F1D7E0", bottom: "#E0B8C9" },
  { top: "#D8F1D7", bottom: "#B8D9B8" },
  { top: "#F1F1D7", bottom: "#E0E0B8" },
  { top: "#F1F1F1", bottom: "#B8E0E0" },
  { top: "#EAD7F1", bottom: "#D9B8E0" },
  { top: "#F1EAD7", bottom: "#E0D9B8" },
  { top: "#D7EAD7", bottom: "#B8D9B8" },
  { top: "#C7B8B8", bottom: "#A69A9A" },
  { top: "#B8D7E0", bottom: "#9AC0C9" },
  { top: "#F1C7D7", bottom: "#D99AC0" },
  { top: "#E0F1C7", bottom: "#C9D99A" },
  { top: "#D7F1E0", bottom: "#B8D9C9" },
  { top: "#F1E0D7", bottom: "#E0C9B8" },
  { top: "#D7D7F1", bottom: "#B8B8E0" },
  { top: "#F1D7F1", bottom: "#E0B8E0" },
  // New diagonal plaid patterns
  { top: "#c8aebf", bottom: "#b0a0aa", stripe: "#a890a0", patternSize: 4, diagonal: true },
  { top: "#d4c8b2", bottom: "#b1a090", stripe: "#c0b0a0", patternSize: 3, diagonal: true },
  { top: "#aac8b2", bottom: "#88a0a0", stripe: "#99b0a0", patternSize: 5, diagonal: true },
  { top: "#c8d4a0", bottom: "#a0b080", stripe: "#b0c080", patternSize: 4, diagonal: true },
  { top: "#d4a0c8", bottom: "#b080a0", stripe: "#c090b0", patternSize: 3, diagonal: true },
  { top: "#a0c8d4", bottom: "#80a0b0", stripe: "#90b0c0", patternSize: 4, diagonal: true },
  // Traditional plaids
  { top: "#D7F1F1", bottom: "#B8E0E0", stripe: "#C0E8E8", patternSize: 4, diagonal: false },
  { top: "#F1D7D7", bottom: "#E0B8B8", stripe: "#E8C8C8", patternSize: 3, diagonal: false },
];

// Apply initial outfit
applyOutfit(player, outfits[0]);

// Function to apply outfit to player sprite
function applyOutfit(player, outfit) {
  player.topColor = outfit.top;
  player.bottomColor = outfit.bottom;
  player.stripe = outfit.stripe || null;
  player.patternSize = outfit.patternSize || 4;
  player.diagonal = outfit.diagonal || false;
}

// Key binding to toggle outfits
window.addEventListener("keydown", (e) => {
  if (e.key.toLowerCase() === "q") {
    currentOutfitIndex++;
    if (currentOutfitIndex >= outfits.length) currentOutfitIndex = 0;
    applyOutfit(player, outfits[currentOutfitIndex]);
    // console.log(`Outfit ${currentOutfitIndex + 1}:`, outfits[currentOutfitIndex]);
  }
});

// ü¶ã Moth Discovery Trigger (add after outfit system)
function checkMothDiscovery() {
  const currentOutfit = outfits[currentOutfitIndex];
  // FIXED: Detect ANY outfit with stripe/pattern (all plaids have this)
  const wearingPlaid = currentOutfit && currentOutfit.stripe !== undefined;
  const underLamp = isUnderLamp(playerX);
  
  if (wearingPlaid && underLamp && idleFrames > 300 && !mothActive) {  // ~5s idle
    spawnLampMoths();
    mothActive = true;
    if (DEBUG) console.log("ü¶ã Moths spawned! (Plaid + Lamp + Idle)");
  }
  
  // Reset if conditions fail
  if (!wearingPlaid || !underLamp || idleFrames === 0) {
    mothActive = false;
    // Optional: despawn moths gradually
    moths.forEach(m => m.alpha *= 0.95);
    moths = moths.filter(m => m.alpha > 0.01);
  }
}

// ‚îÄ‚îÄ‚îÄ PLAYER START ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const playerStartX = 160; // match your actual player start X

// ‚îÄ‚îÄ‚îÄ ORIGINAL BUILDINGS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const buildings = [
  { x: 210, y: 55, width: 90, height: 80 } // existing building
];

// ‚îÄ‚îÄ‚îÄ WINDOWS PER ORIGINAL BUILDING ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const windowsPerBuilding = [
  { xOffset: 30, yOffset: 15, size: 12, hueOffset: 0, timer: detRandom()*200, speed: 0.04 + detRandom()*0.03 },
  { xOffset: 50, yOffset: 15, size: 12, hueOffset: 10, timer: detRandom()*200, speed: 0.04 + detRandom()*0.03 },
  { xOffset: 70, yOffset: 15, size: 12, hueOffset: -10, timer: detRandom()*200, speed: 0.04 + detRandom()*0.03 },
  { xOffset: 30, yOffset: 35, size: 12, hueOffset: 5, timer: detRandom()*200, speed: 0.04 + detRandom()*0.03 },
  { xOffset: 50, yOffset: 35, size: 12, hueOffset: -5, timer: detRandom()*200, speed: 0.04 + detRandom()*0.03 }
];

// ‚îÄ‚îÄ‚îÄ LEFT BUILDINGS (appear when walking left) ‚îÄ‚îÄ
const leftBuildings = [
  { x: playerStartX - 240, y: 55, width: 90, height: 80 }, // first left building
  { x: playerStartX - 360, y: 55, width: 90, height: 80 }  // second left building
];

// ‚îÄ‚îÄ‚îÄ CREATE RANDOM WINDOW TIMERS & FLICKER SPEEDS PER BUILDING ‚îÄ‚îÄ
function createBuildingWindows() {
  return [
    { xOffset: 30, yOffset: 15, size: 12, hueOffset: 0, timer: detRandom()*200, speed: 0.04 + detRandom()*0.03 },
    { xOffset: 50, yOffset: 15, size: 12, hueOffset: 10, timer: detRandom()*200, speed: 0.04 + detRandom()*0.03 },
    { xOffset: 70, yOffset: 15, size: 12, hueOffset: -10, timer: detRandom()*200, speed: 0.04 + detRandom()*0.03 },
    { xOffset: 30, yOffset: 35, size: 12, hueOffset: 5, timer: detRandom()*200, speed: 0.04 + detRandom()*0.03 },
    { xOffset: 50, yOffset: 35, size: 12, hueOffset: -5, timer: detRandom()*200, speed: 0.04 + detRandom()*0.03 }
  ];
}

// ‚îÄ‚îÄ‚îÄ WINDOWS PER LEFT BUILDING ‚îÄ‚îÄ
const leftBuildingWindows = leftBuildings.map(() => createBuildingWindows());

// ‚îÄ‚îÄ‚îÄ LEFT BOUNDARY SETTINGS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const leftMostBuilding = leftBuildings[leftBuildings.length - 1]; // farthest left building
const fadeStartX = leftMostBuilding.x + 40;      // where fade begins
const fadeEndX   = leftMostBuilding.x - 420;     // fully black farther left (increased from -220 for slower fade)

let leftFade = 0; // 0 = no fade, 1 = fully black

function handleLeftBoundary() {
  if (playerX <= fadeStartX) {
    // Linear progress (0 = start, 1 = fully past fadeEndX)
    const linearProgress = (fadeStartX - playerX) / (fadeStartX - fadeEndX);

    // Non-linear ease-in curve for cinematic feel
    leftFade = Math.min(1, linearProgress * linearProgress); // quadratic curve

    // Apply fade overlay
    ctx.fillStyle = `rgba(0,0,0,${leftFade})`;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Reset player when fully faded
    if (leftFade >= 1) {
      playerX = playerStartX; // move back to start
      leftFade = 0;           // reset fade
      shellPileCount = 0;     // reset shell pile count
      stopRain();             // Stop rain audio
      ghostActive = false;
      stillUnderGhost = 0;
      ghostTimer = 0;
      ghostWave = 0;
      ghostMorse = 0;
      puddleReverieActive = false;        // ‚ú® NEW
      puddleReverieTimer = 0;             // ‚ú® NEW
      stillOverPuddle = 0;                // ‚ú® NEW
      puddleReverieWavePhase = 0;         // ‚ú® NEW
      moodTintActive = false;
      moodTintTimer = 0;
      moodVignetteStrength = 0;
      newMoonEvilWinkActive = false;
      newMoonEvilWinkTimer = 0;
      newMoonEvilWinkFrame = 0;
      fullMoonSmileActive = false;
      fullMoonSmileTimer = 0;
      fullMoonSmileFrame = 0;
      playerShootingStars = [];
      rainLevel = 0;
      rainTarget = 0;
      rainIntensity = 0; // Reset smooth rain
      // Reset cat glance variables
      catGlanceTriggered = false;
      catGlancing = false;
      catGlanceTimer = 0;
      catSkidding = false;
      catSkidTimer = 0;
      catFacing = 1;
      pawprints.length = 0; // Clear pawprints
    }
  } else {
    leftFade = 0; // no fade if player is right of start
  }
}

// ‚îÄ‚îÄ‚îÄ DRAW LEFT BUILDINGS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function drawLeftBuildings() {
  leftBuildings.forEach((b, i) => {
    ctx.fillStyle = C.building;
    ctx.fillRect(b.x - playerX * 0.4, b.y, b.width, b.height);

    // Windows with independent flicker per building
    leftBuildingWindows[i].forEach(w => {
      let hue = 42 + w.hueOffset;
      let flickerMult = 1; // Morse pulse multiplier

      // Ghost effect: bottom-left window of leftmost building (i=1, xOffset=30/yOffset=35)
      if (i === 1 && w.xOffset === 30 && w.yOffset === 35 && ghostActive) {
        hue = 170 + 20 * Math.sin(ghostWave); // Cyan pulse (170-190)
        flickerMult = 0.8 + 0.4 * Math.sin(ghostMorse * 2.5); // Morse-like rhythm (dot/dash feel)
      }

      const alpha = (0.55 + Math.sin(w.timer * w.speed * flickerMult) * (ghostActive ? 0.35 : 0.25)) *
                    NIGHT_EFFECTS.windowGlowMultiplier *
                    (0.8 + twilight * 0.4);
      ctx.fillStyle = `hsla(${hue}, 80%, 65%, ${alpha})`;
      ctx.fillRect(b.x + w.xOffset - playerX * 0.4, b.y + w.yOffset, w.size, w.size);

      // Ghost creature: small silhouette with glowing eyes that slowly rises to look
      if (i === 1 && w.xOffset === 30 && w.yOffset === 35 && ghostActive) {
        const winScreenX = ~~(b.x + w.xOffset - playerX * 0.4);
        const winScreenY = ~~(b.y + w.yOffset);

        // Clip to window bounds to prevent ghost from showing outside
        ctx.save();
        ctx.beginPath();
        ctx.rect(winScreenX, winScreenY, w.size, w.size);
        ctx.clip();

        // Base alpha ‚Äî very faint, dims more at high twilight
        const baseAlpha = (0.38 + 0.18 * Math.sin(ghostWave * 0.7)) * (1 - twilight * 0.12);

        // Rise from bottom of window (starts lower, slowly comes up)
        const riseProgress = Math.min(1, ghostTimer / 600); // takes ~10 seconds to fully rise
        const riseOffset = (1 - riseProgress) * 6;           // starts 6px lower

        // Creature body ‚Äî small hunched silhouette (dark gray-blue)
        ctx.fillStyle = `rgba(40, 50, 70, ${baseAlpha * 0.9})`;
        ctx.fillRect(winScreenX + 0.5, winScreenY + 7 + riseOffset, 5, 5);     // main body (moved down 5px total)
        ctx.fillRect(winScreenX + 1.5, winScreenY + 5 + riseOffset, 3, 2);     // head-ish (moved down 5px total)

        // Two glowing eyes ‚Äî tiny, pulsing slowly
        const eyePulse = 0.6 + 0.4 * Math.sin(ghostWave * 1.1 + 0.8);
        ctx.fillStyle = `rgba(180, 240, 255, ${baseAlpha * eyePulse})`; // cyan glow
        ctx.fillRect(winScreenX + 1.2, winScreenY + 8.2 + riseOffset, 1, 1);   // left eye (moved down 5px total)
        ctx.fillRect(winScreenX + 3.8, winScreenY + 8.2 + riseOffset, 1, 1);   // right eye (moved down 5px total)

        // Very faint eye highlight (makes them pop just a tiny bit)
        ctx.fillStyle = `rgba(255, 255, 255, ${baseAlpha * eyePulse * 0.4})`;
        ctx.fillRect(winScreenX + 1.4, winScreenY + 8.4 + riseOffset, 0.6, 0.6); // moved down 5px total
        ctx.fillRect(winScreenX + 4.0, winScreenY + 8.4 + riseOffset, 0.6, 0.6); // moved down 5px total

        ctx.restore(); // Remove clipping
      }

      w.timer += 1;
    });
  });
}

// Particle array for the title
let titleParticles = [];
let titleAnimated = false;
let titleTimer = 0; // Timer for 3-second delay
let hintDelayTimer = 0; // Timer for 10-second post-particle delay

// Lamp fade state (0 = off, 1 = fully on)
let lampAlpha = 0;
const lampFadeSpeed = 0.01;

// ü¶ã Lamp moth discovery
let moths = [];
let idleFrames = 0;
let mothActive = false;

// Helper function to check if player is under lamp
function isUnderLamp(x) {
  return allLampPositions.some(pos => Math.abs(pos - x) < 60);
}

// ‚îÄ‚îÄ‚îÄ PLAYER SPEED BOOST ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let walkSpeed = 0.55; // increased from 0.45 for slightly faster movement
let speedMultiplier = 1.0;

// ‚îÄ‚îÄ‚îÄ SEAGULL CLASS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
class FloatingSeagull {
  constructor(x, y) {
    this.baseX = x; // Base position for drift
    this.x = x;              
    this.baseY = y;          
    this.y = y;
    this.floatOffset = Math.random() * Math.PI * 2; 
    this.size = 4;           
    this.color = '#fff';     
    this.rippleTimer = Math.random() * 100;

    // Wing flap
    this.wingOffset = Math.random() * 2; 
    this.wingFlapSpeed = 0.1 + Math.random() * 0.1;

    // Random flipping behavior - no triggers, just random
    this.facingRight = Math.random() > 0.5; // Start facing random direction
    this.flipTimer = Math.random() * 400 + 300; // Random time until next flip (300-700 frames = 5-12 seconds)
    
    // Gentle horizontal drift
    this.driftPhase = Math.random() * Math.PI * 2; // Random starting point
    this.driftSpeed = 0.001 + Math.random() * 0.0005; // Very slow drift
    this.driftRadius = 2 + Math.random() * 2; // Small drift radius (2-4 pixels)
    
    this.excited = false;
    this.exciteTimer = 0;
    this.exciteAngle = 0;
    this.replyCooldown = 0;
  }

  update(dt) {
    if (this.replyCooldown > 0) this.replyCooldown -= dt;
    
    if (this.excited) {
      this.exciteTimer -= dt;
      this.exciteAngle += 0.2 * dt;
      this.x = this.baseX + Math.sin(this.exciteAngle) * 5;
      this.y = this.baseY + Math.sin(this.exciteAngle * 0.6) * 1.8;
      
      // Drop shells during excitement
      if (Math.random() < 0.3 * dt) {
        spawnShellSparkles(this.x, this.y + 2, 1);
      }
      
      if (this.exciteTimer <= 0) {
        this.excited = false;
        this.x = this.baseX + (Math.random() - 0.5) * 1.5;
        this.y = this.baseY;
      }
    } else {
      // Normal idle
      const wave = Math.sin(Date.now() * 0.002 + this.floatOffset) * 1.5;
      this.y = this.baseY + wave;
      
      this.driftPhase += this.driftSpeed;
      const drift = Math.sin(this.driftPhase) * this.driftRadius;
      this.x = this.baseX + drift;
    }
    
    this.rippleTimer += dt * 0.01;
    
    // Random flipping
    this.flipTimer--;
    if (this.flipTimer <= 0) {
      this.facingRight = !this.facingRight;
      this.flipTimer = Math.random() * 400 + 300;
    }
    
    // Wing flap (excited = faster/bigger)
    const flapMult = this.excited ? 2.2 : 1;
    this.wingOffset = Math.sin(Date.now() * 0.01 * this.wingFlapSpeed * flapMult) * (this.excited ? 2.8 : 1.5);
  }

  draw(ctx, playerX) {
    const drawX = this.x - playerX * 0.7;
    const drawY = this.y;

    ctx.save();

    if (!this.facingRight) {
      ctx.translate(drawX + 3, drawY - 1);
      ctx.scale(-1, 1);
      ctx.translate(-(drawX + 3), -(drawY - 1));
    }

    // --- Body, neck, head, beak (unchanged pixel art) ---
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(drawX, drawY, 4, 1);
    ctx.fillRect(drawX, drawY - 1, 4, 1);
    ctx.fillRect(drawX + 4, drawY - 1, 2, 1);     
    ctx.fillRect(drawX + 6, drawY - 2, 2, 1);     
    ctx.fillRect(drawX + 6, drawY - 3, 1, 1);     
    ctx.fillStyle = '#ffa500';
    ctx.fillRect(drawX + 7, drawY - 2, 1, 1);     

    // --- Wings ---
    const wingBaseX = drawX + 1;   
    const wingBaseY = drawY - 1;   

    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(wingBaseX, wingBaseY);
    ctx.lineTo(wingBaseX - 2, wingBaseY - this.wingOffset);
    ctx.moveTo(wingBaseX + 1, wingBaseY);
    ctx.lineTo(wingBaseX + 3, wingBaseY - this.wingOffset * 0.6);
    ctx.stroke();

    // --- Ripples ---
    const rippleAlpha = 0.15 + Math.sin(this.rippleTimer) * 0.05;
    ctx.fillStyle = `rgba(255,255,255,${rippleAlpha})`;
    ctx.fillRect(drawX, drawY + 1, 5, 1);
    ctx.fillRect(drawX + 1, drawY + 2, 3, 1);

    ctx.restore();
  }
}

// ‚îÄ‚îÄ‚îÄ GLIDING LANDING SEAGULL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
class GlidingLandingSeagull {
  constructor(targetX, targetY) {
    // Start far off-screen up and to the right
    this.x = targetX + 180 + Math.random() * 60;
    this.y = -28;
    this.targetX = targetX;
    this.targetY = targetY;
    this.landX = targetX + 14; // final resting spot
    this.landY = targetY;
    this.speed = 0.3 + Math.random() * 0.3;
    this.landed = false;
    this.wingOffset = 0; 
    this.wingFlapSpeed = 0.2 + Math.random() * 0.15;
    this.size = 4;
    this.color = '#fff';
    this.rippleTimer = Math.random() * 100;
    this.justLanded = false;
    this.splashLife = 0;
    this.wingFold = 1; // 1 = fully open, 0 = folded
    this.facing = -1; // -1 = left, 1 = right
  }

  update(dt) {
    if (!this.landed) {
      // glide toward target
      const dx = this.landX - this.x;
      const dy = this.landY - this.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < 1) {
        this.landed = true;
        this.justLanded = true;
        this.splashLife = 1;
        this.x = this.landX;
        this.y = this.landY;
      } else {
        this.x += (dx / dist) * this.speed * dt;
        this.y += (dy / dist) * this.speed * dt;
      }

      // wing flapping
      this.wingOffset = Math.sin(Date.now() * 0.01 * this.wingFlapSpeed) * 2;
      this.wingFold = 1;
    } else {
      // gentle bob on water
      this.y = this.targetY + Math.sin(Date.now() * 0.005) * 0.5;
      this.wingFold -= dt * 0.01;
      if (this.wingFold < 0) this.wingFold = 0;
      this.wingOffset = this.wingOffset * this.wingFold;
    }

    // ripple timer
    this.rippleTimer += dt * 0.01;

    if (this.justLanded) {
      this.splashLife -= dt * 0.05;
      if (this.splashLife <= 0) {
        this.justLanded = false;
      }
    }
  }

  draw(ctx, playerX) {
    const drawX = this.x - playerX * 0.7;
    const drawY = this.y;

    ctx.save();
    ctx.translate(drawX, drawY);
    ctx.scale(this.facing, 1);

    // --- Draw seagull body, neck, head, beak (local coordinates) ---
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, 4, 1);
    ctx.fillRect(0, -1, 4, 1);
    ctx.fillRect(4, -1, 2, 1);      // neck
    ctx.fillRect(6, -2, 2, 1);      // head
    ctx.fillRect(6, -3, 1, 1);      // top of head
    ctx.fillStyle = '#ffa500';
    ctx.fillRect(7, -2, 1, 1);      // beak

    // --- Wings (aligned to shoulders) ---
    const wingBaseX = 1;
    const wingBaseY = -1; // ‚Üì lowered one pixel

    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 1;
    ctx.beginPath();

    ctx.moveTo(wingBaseX, wingBaseY);
    ctx.lineTo(
      wingBaseX - 3,
      wingBaseY - this.wingOffset * this.wingFold
    );

    ctx.moveTo(wingBaseX, wingBaseY);
    ctx.lineTo(
      wingBaseX + 3,
      wingBaseY - this.wingOffset * this.wingFold
    );

    ctx.stroke();

    // Soft landing splash (expanded)
    if (this.justLanded) {
      const a = 0.35 * this.splashLife;
      ctx.fillStyle = `rgba(255,255,255,${a})`;

      ctx.fillRect(1, 1, 1, 1);
      ctx.fillRect(3, 2, 1, 1);
      ctx.fillRect(-1, 2, 1, 1);

      ctx.fillRect(2, 3, 1, 1);
      ctx.fillRect(0, 3, 1, 1);

      ctx.fillRect(4, 1, 1, 1);
      ctx.fillRect(-2, 1, 1, 1);
    }

    // Ripples only (no feet)
    if (this.landed) {
      const rippleAlpha = 0.15 + Math.sin(this.rippleTimer) * 0.05;
      ctx.fillStyle = `rgba(255,255,255,${rippleAlpha})`;
      ctx.fillRect(0, 1, 5, 1);
      ctx.fillRect(1, 2, 3, 1);
    }

    ctx.restore();
  }
}

// ‚îÄ‚îÄ‚îÄ UPDATE SEAGULLS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const glidingSeagulls = [];
let glidingSeagullTriggered = false;

function updateSeagulls(dt) {
  // Whistled seagull reply secret (trigger when player is near seagulls on screen)
  seagulls.forEach((g, index) => {
    // Convert seagull world position to screen position (account for parallax)
    const seagullScreenX = ~~(g.x - playerX * 0.7); // Seagull parallax factor (matches drawing)
    const playerScreenX = 200; // Player is always at center of screen
    const screenDistance = Math.abs(seagullScreenX - playerScreenX); // Distance on screen
    const playerNearSeagull = screenDistance < 150; // Player within 150px on screen
    
    if (whistling && g.replyCooldown <= 0 && playerNearSeagull && Math.random() < 0.3) {
      g.replyCooldown = 180; // 3s cooldown
      g.excited = true;
      g.exciteTimer = 120; // 2s excitement
      spawnShellSparkles(g.x, g.y + 5, 2); // Initial drop
      playWhistle(1.2); // Higher-pitched echo
    }
  });
  
  // Update floating seagulls
  seagulls.forEach(g => g.update(dt));

  // Update gliding landing seagulls
  glidingSeagulls.forEach(g => {
    g.update(dt);

    // Soft interaction: floating seagulls avoid overlapping the new lander
    seagulls.forEach(f => {
      const dx = g.x - f.x;
      const dy = g.y - f.y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      if (dist < 6) { 
        f.x -= dx * 0.01; // gently shift away
        f.y -= dy * 0.005;
      }
    });
  });
}

// ‚îÄ‚îÄ‚îÄ DRAW SEAGULLS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function drawSeagulls(ctx) {
  seagulls.forEach(g => g.draw(ctx, playerX));
  glidingSeagulls.forEach(g => g.draw(ctx, playerX));
}

// ‚îÄ‚îÄ‚îÄ TRIGGER GLIDING SEAGULL ON OWL HOOT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function triggerGlidingSeagull() {
  if (glidingSeagullTriggered) return;

  glidingSeagullTriggered = true;

  // Land near the existing group, not exactly on them
  const target = seagulls[Math.floor(seagulls.length * 0.5)] || { x: levelEndX + 40, baseY: DOCK_CONFIG.waterLevel };

  glidingSeagulls.push(
    new GlidingLandingSeagull(target.x + 10, target.baseY),
  );
}

// ‚îÄ‚îÄ‚îÄ END SCREEN SYSTEM ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let gameEnded = false;

// --- Post-ending Hint Screen System ---
class HintScreen {
  constructor(tips, fadeDuration = 2000, displayDuration = 4000) {
    this.tips = tips;                    // Array of strings
    this.fadeDuration = fadeDuration;    // Fade in/out time in ms
    this.displayDuration = displayDuration; 
    this.active = false;
    this.alpha = 0;
    this.startTime = 0;
    this.phase = 'fadeIn';               // 'fadeIn', 'display', 'fadeOut'
    this.currentTip = '';
  }

  trigger() {
    // console.log("HintScreen.trigger() called!");
    this.active = true;
    this.alpha = 0;
    this.startTime = performance.now();
    this.phase = 'fadeIn';
    // Pick a random tip
    this.currentTip = this.tips[Math.floor(Math.random() * this.tips.length)];
    // console.log("Selected tip:", this.currentTip);
  }

  update() {
    if (!this.active) return;

    const now = performance.now();
    const elapsed = now - this.startTime;

    if (this.phase === 'fadeIn') {
      this.alpha = Math.min(1, elapsed / this.fadeDuration);
      if (elapsed >= this.fadeDuration) {
        this.phase = 'display';
        this.startTime = now;
      }
    } else if (this.phase === 'display') {
      this.alpha = 1;
      if (elapsed >= this.displayDuration) {
        this.phase = 'fadeOut';
        this.startTime = now;
        // Reset game immediately when fade-out starts
        this.resetGame();
      }
    } else if (this.phase === 'fadeOut') {
      this.alpha = Math.max(0, 1 - elapsed / this.fadeDuration);
      if (elapsed >= this.fadeDuration) {
        this.active = false;
        // Game already reset, no need to call resetGame() again
      }
    }
  }

  draw(ctx, canvasWidth, canvasHeight) {
    if (!this.active) return;

    // console.log("Drawing hint screen - alpha:", this.alpha, "phase:", this.phase);
    
    ctx.save();
    ctx.globalAlpha = this.alpha;
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvasWidth, canvasHeight);

    ctx.fillStyle = '#fff';
    ctx.font = '16px monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(this.currentTip, canvasWidth / 2, canvasHeight / 2);
    ctx.restore();
  }

  resetGame() {
    // Reset game state
    gameEnded = false;
    playerX = 40;
    twilight = 0;
    moving = false;
    stepTimer = 0;
    stepFrame = 0;
    cat.triggered = false;
    cat.active = false;
    catGlanceTriggered = false;
    catGlancing = false;
    catGlanceTimer = 0;
    catSkidding = false;
    catSkidTimer = 0;
    catFacing = 1;
    pawprints.length = 0; // Clear pawprints
    titleAnimated = false;
    titleTimer = 0;
    hintDelayTimer = 0; // Reset hint delay timer
    titleParticles = [];
    moodTintActive = false;
    moodTintTimer = 0;
    moodVignetteStrength = 0;
    newMoonEvilWinkActive = false;
    newMoonEvilWinkTimer = 0;
    newMoonEvilWinkFrame = 0;
    fullMoonSmileActive = false;
    fullMoonSmileTimer = 0;
    fullMoonSmileFrame = 0;
    playerShootingStars = [];
    rainLevel = 0;
    rainTarget = 0;
    rainIntensity = 0; // Reset smooth rain
    shellPileCount = 0; // Reset shell pile count
    ghostActive = false;
    stillUnderGhost = 0;
    ghostTimer = 0;
    ghostWave = 0;
    ghostMorse = 0;
    puddleReverieActive = false;        // ‚ú® NEW
    puddleReverieTimer = 0;             // ‚ú® NEW
    stillOverPuddle = 0;                // ‚ú® NEW
    puddleReverieWavePhase = 0;         // ‚ú® NEW
    // console.log("Game reset");
  }
}

// Define some tips
const desktopHints = [
  "HOLD SHIFT TO RUN",
  "PRESS Q FOR OUTFITS",
  "PAY ATTENTION TO DETAILS",
  "PRESS R FOR RAIN",
  "INTERACT WITH THE MOON",
  "CHECK PUDDLES FOR REFLECTIONS",
  "PRESS W TO WHISTLE",
  "PRESS S AND MAKE A WISH",
  "PRESS M TO VIEW MOON",
  "SIT WITH SILENCE",
  "PRESS N TO CYCLE MOON PHASES"
];

const mobileHints = [
  "DOUBLE-TAP ARROWS TO RUN",
  "TAP üëï FOR OUTFITS",
  "PAY ATTENTION TO DETAILS",
  "TAP üåßÔ∏è FOR RAIN",
  "INTERACT WITH THE MOON",
  "CHECK PUDDLES FOR REFLECTIONS",
  "TAP üéµ TO WHISTLE",
  "TAP ‚≠ê AND MAKE A WISH",
  "TAP üåï TO VIEW MOON",
  "SIT WITH SILENCE",
  "TAP üåô TO CYCLE MOON PHASES"
];

const isMobileDevice = window.innerWidth <= 1024;
const hintTips = isMobileDevice ? mobileHints : desktopHints;

// Create a HintScreen instance
const hintScreen = new HintScreen(hintTips);

// Call this when the player reaches the end
function triggerEndScreen() {
  gameEnded = true;
}

function drawEndScreen() {
  // Clear screen
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // 1Ô∏è‚É£ Draw sky with all atmospheric layers
  drawSky();
  drawTwilightOverlay();
  drawHorizonGradient();
  drawAtmosphericWash(ctx); // üå´Ô∏è Subtle moon phase atmosphere
  
  // 2Ô∏è‚É£ Draw stars and shooting stars
  drawStars();
  drawShootingStars();
  
  // üåï Draw moon (between stars and clouds)
  drawMoon(ctx);
  
  // 3Ô∏è‚É£ Draw clouds
  drawClouds();
  
  // 4Ô∏è‚É£ Apply twilight gradient
  drawTwilightGradient();

  // 5Ô∏è‚É£ Draw rain
  drawRain();
  
  // 6Ô∏è‚É£ Draw the player
  drawPlayer();
  
  // 7Ô∏è‚É£ Draw reflections (water/puddle)
  drawReflections();

  // 8Ô∏è‚É£ Title text and animation
  if (!titleAnimated) {
    // Calculate fade-out after particles appear
    let textAlpha = 1.0;
    if (titleTimer >= 3) { // After 3 seconds, start fading
      const fadeProgress = (titleTimer - 3) / 0.5; // Fade over 0.5 seconds (much quicker)
      textAlpha = Math.max(0, 1 - fadeProgress);
    }
    
    // Draw title text with fade
    ctx.fillStyle = `rgba(242, 233, 228, ${textAlpha})`;
    ctx.font = "24px monospace";
    ctx.textAlign = "center";
    ctx.fillText("Twilight", W/2, H/2);
    
    // Wait a moment, then capture and explode it
    titleTimer += 1/60;
    if (titleTimer >= 3) { // Wait 3 seconds
      // Capture text BEFORE setting titleAnimated = true
      initTitleParticles();
    }
    
    // Hide text completely after fade
    if (textAlpha <= 0) {
      titleAnimated = true;
    }
  }
  
  // 9Ô∏è‚É£ Draw title particles (if initialized)
  drawTitleParticles();
  
  // üîü Add subtle noise
  drawNoise();
}

canvas.addEventListener("click", function() {
  // Activate AudioContext on first click (browser requirement)
  if (!window.audioCtx) {
    window.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    // console.log('AudioContext activated on click');
  }
  if (window.audioCtx.state === 'suspended') {
    window.audioCtx.resume();
    if (DEBUG) console.log('AudioContext resumed');
  }
});

canvas.addEventListener("touchstart", function(e) {
  e.preventDefault(); // Prevent scrolling on mobile
  // Activate AudioContext on first touch
  if (!window.audioCtx) {
    window.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    // console.log('AudioContext activated on touch');
  }
  if (window.audioCtx.state === 'suspended') {
    window.audioCtx.resume();
    if (DEBUG) console.log('AudioContext resumed');
  }
});


window.addEventListener("keydown", e => {
  // Check both Shift key press AND shiftKey modifier (for mobile double-tap)
  if (e.key === "Shift" || e.shiftKey) {
    speedMultiplier = 2.5; // walk faster with boost
  }
});

window.addEventListener("keyup", e => {
  // Reset speed when Shift released OR when shiftKey modifier is gone
  if (e.key === "Shift" || (e.shiftKey === false && speedMultiplier > 1.0)) {
    speedMultiplier = 1.0; // normal speed
  }
});

// ‚îÄ‚îÄ‚îÄ DRAW DOCK LAMP GLOW (DIRECT POSITIONING) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function drawDockLampGlow(lampTipX, lampTipY, offsetX = 0, offsetY = 0) {
  // Final lamp tip coordinates (allow for fine-tuning if needed)
  const finalX = lampTipX + offsetX;
  const finalY = lampTipY + offsetY;

  const glowAlphaBase = 0.12;
  const glowFlicker = Math.sin(Date.now() * 0.03) * 0.04; // faint flicker
  const glowAlpha = glowAlphaBase + glowFlicker;

  ctx.fillStyle = `rgba(255, 230, 180, ${glowAlpha})`;

  // glow pixels directly under the lamp tip
  const glowOffsets = [
    {dx: 0, dy: 0},
    {dx: -1, dy: 1}, {dx: 1, dy: 1},
    {dx: -1, dy: 2}, {dx: 0, dy: 2}, {dx: 1, dy: 2},
    {dx: 0, dy: 3}
  ];

  glowOffsets.forEach(o => {
    ctx.fillRect(finalX + o.dx, finalY + o.dy, 1, 1);
  });
}

// ===== Secondary Drift Particles (slow sideways arcs) =====
let driftParticles = [];

// Call this once to create particles from the "Twilight" text
function initTitleParticles() {
    if (DEBUG) console.log("üåü Creating title particles from 'Twilight' text...");
    const textWidth = 100;  // Reduced from 120
    const textHeight = 20;  // Reduced from 40

    // Capture the area where text was drawn
    const imageData = ctx.getImageData(W/2 - textWidth/2, H/2 - textHeight/2, textWidth, textHeight);
    const data = imageData.data;

    titleParticles = [];
    driftParticles = [];

    for (let y = 0; y < textHeight; y++) {
        for (let x = 0; x < textWidth; x++) {
            const i = (y * textWidth + x) * 4;
            const alpha = data[i + 3] / 255;
            if (alpha > 0.1) {
                const px = W/2 - textWidth/2 + x;
                const py = H/2 - textHeight/2 + y;
                // Avoid creating particles exactly at (0,0) to prevent corner pixel
                if (px >= 1 && py >= 1) {
                    titleParticles.push({
                        x: px,
                        y: py,
                        baseX: px,
                        baseY: py,
                        angle: detRandom() * Math.PI * 2,
                        radius: 0.5 + detRandom() * 1.5,
                        speed: 0.001 + detRandom() * 0.002,
                        vy: -0.1 - detRandom() * 0.2,
                        alpha: 1,
                        color: `rgb(${data[i]},${data[i + 1]},${data[i + 2]})`,
                        amplitudeX: 20 + detRandom() * 40,
                        amplitudeY: 10 + detRandom() * 20,
                        phase: detRandom() * Math.PI * 2,
                        driftSpeed: 0.0005 + detRandom() * 0.001,
                        driftVy: -0.03 - detRandom() * 0.05,
                        driftAlpha: 0.6 + detRandom() * 0.4,
                        driftColor: `rgba(242,233,228,1)`
                    });

                    // 40% chance to create drift particle (RESTORED from original)
                    if (detRandom() < 0.4) {
                        driftParticles.push({
                            x: px + (detRandom() * 20 - 10),
                            y: py + (detRandom() * 20 - 10),
                            baseX: 0,
                            baseY: 0,
                            amplitudeX: 20 + detRandom() * 40,
                            amplitudeY: 10 + detRandom() * 20,
                            phase: detRandom() * Math.PI * 2,
                            speed: 0.0005 + detRandom() * 0.001,
                            vy: -0.03 - detRandom() * 0.05,
                            alpha: 0.6 + detRandom() * 0.4,
                            color: `rgba(242,233,228,1)`
                        });
                    }
                }
            }
        }
    }

    // if (DEBUG) console.log(`üåü Created ${titleParticles.length} title particles and ${driftParticles.length} drift particles from 'Twilight' text`);
    titleAnimated = true;
}

// Draw and update particles each frame
function drawTitleParticles() {
        // Debug: Log particle count and hint state (only every 60 frames to prevent spam)
    if (titleAnimated && titleParticles.length > 0 && Math.random() < 0.017) { // ~1/60 chance
        if (DEBUG) console.log(`üåü Drawing ${titleParticles.length} title particles, ${driftParticles.length} drift particles`);
    }

    // Trigger hint screen when all title particles are gone AND 10 seconds have passed
    if (titleParticles.length === 0 && !hintScreen.active && titleAnimated) {
        // Start the delay timer if not already started
        if (!hintDelayTimer) {
            hintDelayTimer = 0;
            if (DEBUG) console.log("Starting 20-second hint delay...");
        }
        
        hintDelayTimer += 1/60; // Increment by frame time (assuming 60 FPS)
        
        if (hintDelayTimer >= 20) { // 20 seconds delay
            if (DEBUG) console.log("Triggering hint screen after 20-second delay!");
            hintScreen.trigger();
        }
    }

    if (!titleAnimated) return;

    // Update title particles with safety checks
    for (let i = titleParticles.length - 1; i >= 0; i--) {
        const p = titleParticles[i];
        
        // Safety check: ensure particle exists and has valid properties
        if (!p || typeof p.x !== 'number' || typeof p.y !== 'number') {
            titleParticles.splice(i, 1);
            continue;
        }

        p.angle += p.speed;
        p.x = p.baseX + Math.cos(p.angle) * p.radius;
        p.y = p.baseY + Math.sin(p.angle) * p.radius + p.vy;
        
        // Gentle outward drift - orbit slowly expands
        p.baseX += Math.cos(p.angle) * 0.02;
        p.baseY += Math.sin(p.angle) * 0.02;

        p.alpha -= 0.004; // Slower fade - particles travel farther
        if (p.alpha <= 0) {
            titleParticles.splice(i, 1);
            continue;
        }

        // Safety check: ensure coordinates are finite before drawing
        if (!isFinite(p.x) || !isFinite(p.y) || !isFinite(p.alpha)) {
            titleParticles.splice(i, 1);
            continue;
        }

        // Draw particle with random sparkle (RESTORED original behavior)
        if (Math.random() < 0.01) {
            ctx.fillStyle = "#fff";
            ctx.globalAlpha = p.alpha;
            ctx.fillRect(p.x, p.y, 1, 1);
        }

        ctx.globalAlpha = Math.max(0, Math.min(1, p.alpha));
        ctx.fillStyle = p.color;
        ctx.fillRect(Math.floor(p.x), Math.floor(p.y), 1, 1); // RESTORED 1x1 size
        
        // Occasional white sparkle
        if (Math.random() < 0.01) {
            ctx.fillStyle = "#fff";
            ctx.globalAlpha = Math.max(0, Math.min(1, p.alpha));
            ctx.fillRect(Math.floor(p.x), Math.floor(p.y), 1, 1);
            ctx.fillRect(Math.floor(p.x), Math.floor(p.y), 2, 2);
        }
    }

    // Update drift particles with safety checks
    for (let i = driftParticles.length - 1; i >= 0; i--) {
        const p = driftParticles[i];
        
        // Safety check: ensure particle exists and has valid properties
        if (!p || typeof p.x !== 'number' || typeof p.y !== 'number') {
            driftParticles.splice(i, 1);
            continue;
        }

        p.phase += p.speed;
        const dx = Math.sin(p.phase) * p.amplitudeX * 0.01;
        const dy = Math.cos(p.phase) * p.amplitudeY * 0.01 + p.vy;

        p.x += dx;
        p.y += dy;

        p.alpha -= 0.0008;
        if (p.alpha <= 0) {
            driftParticles.splice(i, 1);
            continue;
        }
        
        // Safety check: ensure coordinates are finite before drawing
        if (!isFinite(p.x) || !isFinite(p.y) || !isFinite(p.alpha)) {
            driftParticles.splice(i, 1);
            continue;
        }

        // Draw drift particle with random sparkle (RESTORED original behavior)
        if (Math.random() < 0.003) {
            ctx.fillStyle = "#fff";
            ctx.globalAlpha = p.alpha;
            ctx.fillRect(p.x, p.y, 1, 1);
        }

        ctx.globalAlpha = Math.max(0, Math.min(1, p.alpha));
        ctx.fillStyle = p.color;
        ctx.fillRect(Math.floor(p.x), Math.floor(p.y), 1, 1); // RESTORED 1x1 size
    }

    ctx.globalAlpha = 1;
}

// ‚îÄ‚îÄ‚îÄ CAT EVENT STATE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let cat = {
    active: false,           // becomes true once the player hits triggerX
    x: 0,                    // starting X
    y: 145,                 // lower on the road (player is at 120, road is at 130)
    speed: 1.5,              // running speed
    frame: 0,                // animation frame for legs/tail
    frameSpeed: 0.15,
    triggered: false,        // ensures it happens only once
    interacting: false,      // NEW: cat is interacting with whistle
    interactTimer: 0,        // NEW: interaction timer
    skidTimer: 0             // NEW: skid timer for slide-stop
};

// Window Ghost Wave secret
let ghostActive = false;
let ghostTimer = 0;
let stillUnderGhost = 0;
let ghostWave = 0;
let ghostMorse = 0;

// ‚ú® NEW: Puddle Reverie secret - reflection becomes independent
let puddleReverieActive = false;
let puddleReverieTimer = 0;
let stillOverPuddle = 0;
let puddleReverieWavePhase = 0;

// Cat glance and pawprint system
let catGlanceTriggered = false;
let catGlancing = false;
let catGlanceTimer = 0;
let catSkidding = false;
let catSkidTimer = 0;
let catFacing = 1; // 1 = right, -1 = left
const pawprints = [];

// Define where the cat appears
const catTriggerX = 1200; // playerX coordinate to start the cat running
const catEndX = catTriggerX + 150; // how far the cat runs (increased for better visibility)

// ‚îÄ‚îÄ‚îÄ UFO EVENT STATE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let ufoTriggered = false;
let ufo = {
  active: false,
  x: 0,
  y: 0,
  alpha: 0,
  vy: -0.3,
  pathStartX: 0,
  pathStartY: 0,
  t: 0,
  humStopper: null // Function to stop the hum sound
};

// ‚îÄ‚îÄ‚îÄ UFO SPARKLE PARTICLES ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let ufoSparkles = [];

// üõ∏ Soft Ambient UFO Hum (Barely There)
function playUfoHum(active) {
    if (!active) return;
    const audioCtx = getAudioCtx();

    const now = audioCtx.currentTime;

    const osc = audioCtx.createOscillator();
    osc.type = "sine";
    osc.frequency.setValueAtTime(72, now);

    const gain = audioCtx.createGain();
    gain.gain.setValueAtTime(0.0001, now);
    gain.gain.exponentialRampToValueAtTime(0.06, now + 1.5);

    const lfo = audioCtx.createOscillator();
    const lfoGain = audioCtx.createGain();
    lfo.frequency.value = 0.4;
    lfoGain.gain.value = 6;

    lfo.connect(lfoGain);
    lfoGain.connect(osc.frequency);

    osc.connect(gain);
    gain.connect(audioCtx.destination);

    osc.start(now);
    lfo.start(now);

    return () => {
        gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 1.5);
        osc.stop(audioCtx.currentTime + 0.6);
    }
}


// üñ§ Green Sparkle Beam (Tiny, Fleeting)
function spawnUfoSparkles(x, y) {
  // console.log("UFO SPARKLES SPAWNED"); // Debug: Confirm spawning
  const count = 10 + Math.floor(Math.random() * 6); // 10‚Äì15 sparkles

    for (let i = 0; i < count; i++) {
        ufoSparkles.push({
            x: x + Math.random() * 10 - 5,
            y: y + Math.random() * 2,
            vy: 0.3 + Math.random() * 0.8,
            life: 20 + Math.random() * 10,
            alpha: 0.4 + Math.random() * 0.3, // Reduced from 0.9-1.0 to 0.4-0.7 for more transparency
            size: 1
        });
    }
}

function spawnPlayerShootingStar() {
  // Use the clean cinematic version
  if (playerShootingStars.length > 0) return;
  playerShootingStars.push(new PlayerShootingStar());
  // console.log("üå† Wish made");
}

// üñ§ Green Sparkle Beam (Tiny, Fleeting)

function updateUfoSparkles() {
    for (let i = ufoSparkles.length - 1; i >= 0; i--) {
        const sparkle = ufoSparkles[i];
        sparkle.y += sparkle.vy;
        sparkle.life--;
        sparkle.alpha *= 0.96; // Slower fade (was 0.92)
        
        if (sparkle.life <= 0) {
            ufoSparkles.splice(i, 1);
        }
    }
    
    // Random sparkle pulses when UFO is visible
    if (ufo.active && Math.random() < 0.02) { // Increased from 0.004 to 0.02 for testing
        spawnUfoSparkles(ufo.x, ufo.y + 10);
        // console.log('UFO sparkle spawned at:', ufo.x, ufo.y + 10);
    }
}

function drawUfoSparkles() {
    ufoSparkles.forEach(sparkle => {
        // Use UFO's actual screen position directly
        const screenX = 220 + (sparkle.x - 600); // UFO is at world X=600, screen X=220
        const screenY = sparkle.y;
        
        // Wrap sparkle draw defensively
        ctx.save();
        ctx.globalAlpha = sparkle.alpha;
        
        // Optional color shift on fade (subtle magic)
        const color = sparkle.life > 15 ? "#6AFF6A" : "#3BCF72";
        ctx.fillStyle = color;
        
        ctx.fillRect(
            Math.floor(screenX), // Use calculated screen position
            Math.floor(screenY),
            sparkle.size,
            sparkle.size
        );
        
        ctx.restore(); // Reset all context state
    });
}

// Phase mood tint overlay
let moodTintActive = false;
let moodTintTimer = 0;
let moodTintColor = { h: 0, s: 0, l: 0, a: 0 };
let moodVignetteStrength = 0;

// ‚îÄ‚îÄ‚îÄ GAME STATE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const C = {
  street: "#3a3a4f",
  sidewalk: "#4a4a60",
  building: "#22223b",
  fence: "#9a8c98",
  light: "#e09f3e",
  player: [242,233,228],
  starA: "#f2e9e4",
  starB: "#d6cfe3",
  pole: "#9a8c98",
  lampDark: "#3a3530",
  lampLight: "#e09f3e"
};

// ‚îÄ‚îÄ‚îÄ FIREFLIES (Expanded range: 80-160) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const fireflies = [];
const fireflyRandomOffsets = Array.from({length: 30}, () => detRandom() - 0.5); // Precompute flicker offsets

for (let i = 0; i < 15; i++) {
  fireflies.push({
    x: detRandom() * W,
    y: 80 + detRandom() * 80,  // Expanded from 110+30 to 80+80
    alpha: detRandom() * 0.8,
    flickerSpeed: 0.01 + detRandom() * 0.02,
    dx: (detRandom() - 0.5) * 0.8,  // Increased from 0.2 to 0.8
    dy: (detRandom() - 0.5) * 0.4   // Increased from 0.1 to 0.4
  });
}

function updateFireflies() {
  // Always update fireflies - remove optimization blocking
  fireflies.forEach((f, i) => {
    f.alpha += fireflyRandomOffsets[i % fireflyRandomOffsets.length] * f.flickerSpeed;
    f.alpha = Math.max(0.2, Math.min(f.alpha, 1));
    
    f.x += f.dx;
    f.y += f.dy;
    
    if(f.x < 0) f.x = W;
    if(f.x > W) f.x = 0;
    if(f.y < 80) f.y = 160;  // Expanded from 125-145 to 80-160
    if(f.y > 160) f.y = 80;
  });
}

function drawFireflies() {
  fireflies.forEach(f => {
    ctx.globalAlpha = f.alpha;
    drawDot(f.x, f.y, "#f2e9b0");
    ctx.globalAlpha = 1;
  });
}

// ü¶ã Draw moths (pixel-soft, not glowy)
function drawMoths() {
  moths.forEach(m => {
    // Convert world coordinates to screen coordinates (same parallax as player)
    const screenX = Math.floor(m.x - playerX * 0.7);
    const screenY = Math.floor(m.y);
    
    // Warm yellow-orange glow
    ctx.fillStyle = `rgba(255, 220, 150, ${m.alpha * 0.8})`;
    ctx.fillRect(screenX, screenY, 1, 1);

    // Tiny wing shimmer with orange tint
    ctx.fillStyle = `rgba(255, 200, 120, ${m.alpha * 0.4})`;
    ctx.fillRect(screenX + 1, screenY, 1, 1);
  });
}

// ü¶ã Spawn Lamp Moths (around player, not high above lamps)
function spawnLampMoths() {
  if (DEBUG) console.log("ü¶ã Spawning moths AROUND PLAYER!");
  moths.length = 0; // Clear old ones

  const parallax = 0.7;
  const playerScreenCenterX = 60;  // Player's fixed screen X
  const playerScreenCenterY = 115; // Around player chest/shoulders (tweak if needed)

  for (let i = 0; i < 12; i++) { // 12 for a nice full cluster (was 8)
    const screenDX = (Math.random() - 0.5) * 50; // Screen offset: -25 to +25 px wide
    const screenDY = (Math.random() - 0.5) * 40; // Screen offset: -20 to +20 px tall

    // Convert to WORLD coords so screen pos = player center + offsets
    const worldX = playerX * parallax + (playerScreenCenterX + screenDX);
    const worldY = playerScreenCenterY + screenDY;

    moths.push({
      x: worldX,
      y: worldY,
      vx: (Math.random() - 0.5) * 0.03, // Slightly more flutter
      vy: (Math.random() - 0.5) * 0.02,
      size: 1 + Math.random() * 0.8,
      alpha: 0,
      phase: Math.random() * Math.PI * 2
    });
  }
  if (DEBUG) console.log(`ü¶ã Spawned ${moths.length} moths around player screen (${playerScreenCenterX}, ${playerScreenCenterY})`);
}

// ü¶ã Moth Update System (time-based discovery)
function updateMoths() {
  moths.forEach(m => {
    m.phase += 0.005; // Slower phase change

    m.x += m.vx + Math.sin(m.phase) * 0.01; // Much slower drift
    m.y += m.vy + Math.cos(m.phase) * 0.005; // Much slower drift

    if (mothActive) {
      m.alpha = Math.min(1, m.alpha + 0.01);
    } else {
      m.alpha -= 0.01;
    }
  });

  moths = moths.filter(m => m.alpha > 0);
}

// ‚îÄ‚îÄ‚îÄ SHOOTING STARS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const shootingStars = [];
// playerStars, lastPlayerStarTime, PLAYER_STAR_COOLDOWN moved to top of file

function updateShootingStars() {
  if (twilight < 0.4) return;
  
  if (detRandom() < 0.008) {
    shootingStars.push({
      x: detRandom() * W,
      y: detRandom() * 50,
      length: 1 + Math.floor(detRandom() * 2),
      speed: 2 + detRandom() * 1.5,
      alpha: 1
    });
  }

  shootingStars.forEach(s => {
    s.x += s.speed;
    s.y += s.speed * 0.3;
    s.alpha -= 0.01;
  });
  
  for (let i = shootingStars.length - 1; i >= 0; i--) {
    const s = shootingStars[i];
    if (s.alpha <= 0 || s.x > W || s.y > H) {
      shootingStars.splice(i, 1);
    }
  }
}

// ‚îÄ‚îÄ‚îÄ PLAYER SHOOTING STAR SECRET ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Clean cinematic shooting star system - ONE beautiful star per wish

function spawnPlayerShootingStar() {
  // Limit to 1 at a time for rarity
  if (playerShootingStars.length > 0) return;

  playerShootingStars.push(new PlayerShootingStar());
  // console.log("üå† Wish made");
}

function updatePlayerShootingStars() {
  for (let i = playerShootingStars.length - 1; i >= 0; i--) {
    const star = playerShootingStars[i];
    star.update();

    if (!star.isAlive()) {
      playerShootingStars.splice(i, 1);
    }
  }
}

function drawPlayerShootingStars(ctx) {
  playerShootingStars.forEach(star => star.draw(ctx));
}

// The beautiful cinematic PlayerShootingStar class
class PlayerShootingStar {
  constructor() {
    // Spawn in visible screen area - ULTRA VISIBLE
    this.x = playerX + W + 50; // Start from right edge of screen
    this.y = 30 + Math.random() * 80; // Upper-mid sky
    this.speed = 2.5 + Math.random() * 1.0; // Fast streak across screen
    this.angle = Math.PI; // Shoot left across screen (screen-space)
    this.life = 120 + Math.random() * 60; // 2-3 seconds visible
    this.age = 0;
    this.alpha = 1.0; // Full brightness
    this.twinklePhase = Math.random() * Math.PI * 2;
  }

  update() {
    this.age++;
    this.x += Math.cos(this.angle) * this.speed;
    this.y += Math.sin(this.angle) * this.speed;

    // Bright twinkle + fade
    this.alpha = 1.0 + 0.3 * Math.sin(this.twinklePhase + this.age * 0.3);
    this.alpha *= (1 - this.age / this.life); // fade out

    this.twinklePhase += 0.2;
  }

  draw(ctx) {
    if (this.age >= this.life || this.alpha < 0.05) return;

    // Use screen-space coordinates (no parallax issues)
    const screenX = this.x - playerX;
    const screenY = this.y;

    // BRIGHT CORE STAR - Pure glowing magenta head for max glow
    ctx.globalAlpha = this.alpha;
    ctx.fillStyle = `rgba(255, 0, 255, ${this.alpha * 1.5})`;  // #FF00FF pure magenta head
    ctx.fillRect(screenX, screenY, 3, 3);

    // ULTRA BRIGHT STREAKING TRAIL - Neon purple fading to deep violet
    for (let i = 1; i <= 12; i++) {
      const trailAlpha = this.alpha * (1 - i / 13) * 0.9;
      const trailSize = 3 - (i * 0.15); // Gradually smaller
      
      // Ultraviolet blacklight neon purple trail with hue shift
      const trailHueShift = 280 + i * 2;  // subtle hue shift 280-300 (magenta ‚Üí violet)
      ctx.fillStyle = `hsla(${trailHueShift}, 100%, ${50 + i * 5}%, ${trailAlpha})`;
      
      const tx = screenX - Math.cos(this.angle) * i * 3.5;
      const ty = screenY - Math.sin(this.angle) * i * 3.5;
      ctx.fillRect(tx, ty, trailSize, trailSize);
    }

    // GLOW EFFECT - Blacklight fluorescence effect
    ctx.save();
    ctx.shadowColor = 'rgba(191, 0, 255, 0.6)';
    ctx.shadowBlur = 4;
    ctx.globalAlpha = this.alpha * 0.3;
    ctx.fillStyle = `rgba(138, 43, 226, ${this.alpha * 0.8})`;  // #8A2BE2 Blue Violet bloom
    ctx.fillRect(screenX - 2, screenY - 2, 7, 7);
    ctx.restore();

    ctx.globalAlpha = 1;
  }

  isAlive() {
    return this.age < this.life && this.alpha > 0.05;
  }
}

function drawShootingStars() {
  shootingStars.forEach(s => {
    ctx.globalAlpha = s.alpha;
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(s.x, s.y, s.length, 1);
    ctx.globalAlpha = 1;
  });
}

// ‚îÄ‚îÄ‚îÄ STARS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const stars = [];

// ‚îÄ‚îÄ‚îÄ STATIC DITHERING ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const staticDither = [];
for(let y=0; y<H; y++){
  staticDither[y] = [];
  for(let x=0; x<W; x++){
    staticDither[y][x] = detRandom() < 0.3;
  }
}

// ‚îÄ‚îÄ‚îÄ DRAWING HELPERS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Optimized helper functions for common pixel operations
function fillPixelRect(x, y, w, h, color) {
  ctx.fillStyle = color;
  ctx.fillRect(~~x, ~~y, w, h);
}

function drawDot(x, y, color = '#fff', size = 1) {
  // Prevent drawing exactly at (0,0) to avoid corner pixel artifact
  if (~~x === 0 && ~~y === 0) return;
  ctx.fillStyle = color;
  ctx.fillRect(~~x, ~~y, size, size);
}

function drawPixel(x, y, color) {
  // Prevent drawing exactly at (0,0) to avoid corner pixel artifact
  if (~~x === 0 && ~~y === 0) return;
  ctx.fillStyle = color;
  ctx.fillRect(~~x, ~~y, 1, 1);
}

// ‚îÄ‚îÄ‚îÄ CACHED PATTERNS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Pre-create patterns to avoid expensive creation in draw loops
let cachedFencePattern = null;

function updateFencePattern() {
  const patternCanvas = document.createElement('canvas');
  patternCanvas.width = 12;
  patternCanvas.height = 12;
  const pctx = patternCanvas.getContext('2d');
  
  // Draw 2x2 checkerboard using fence color and a darker variant
  pctx.fillStyle = C.fence;
  pctx.fillRect(0, 0, 6, 6);
  pctx.fillRect(6, 6, 6, 6);
  pctx.fillStyle = '#7a6c78'; // Darker variant of fence color
  pctx.fillRect(0, 6, 6, 6);
  pctx.fillRect(6, 0, 6, 6);
  
  cachedFencePattern = pctx.createPattern(patternCanvas, 'repeat');
}

function getFencePattern() {
  if (!cachedFencePattern) updateFencePattern();
  return cachedFencePattern;
}

// ‚îÄ‚îÄ‚îÄ MICRO-MOTION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const fenceOffsets = [];
const fenceExtension = 10; // 10 posts = 120px extension (12px spacing)
for (let i = 0; i < Math.ceil(W/12) + fenceExtension; i++) fenceOffsets.push(detRandom()*2);
class Cloud {
  constructor(x, y, width, height, density = 16, baseHue = 240) {
    this.x = Number.isFinite(x) ? x : 0;
    this.y = Number.isFinite(y) ? y : 60;
    this.width = Number.isFinite(width) ? width : 80;
    this.height = Number.isFinite(height) ? height : 30;
    this.baseHue = Number.isFinite(baseHue) ? baseHue : 240;
    this.drift = 0.002 + Math.random() * 0.004;
    this.squares = [];

    // weighted size choices (more small than huge)
    const sizes = [2, 4, 6, 8];
    const weights = [0.35, 0.30, 0.22, 0.13];

    const pickSize = () => {
      const r = Math.random();
      let acc = 0;
      for (let i = 0; i < sizes.length; i++) {
        acc += weights[i];
        if (r < acc) return sizes[i];
      }
      return 4;
    };

    for (let i = 0; i < density; i++) {
      const size = pickSize();
      const alpha = size >= 6 ? 0.15 + Math.random() * 0.2 : 0.25 + Math.random() * 0.25;

      this.squares.push({
        x: Math.random() * (width * 0.6 - size) + width * 0.2, // Tighter horizontal spread
        y: Math.random() * (height * 0.6 - size) + height * 0.2, // Tighter vertical spread
        size,
        alpha
      });
    }
  }

  update(dt = 1) {
    if (!Number.isFinite(this.x)) this.x = 0;
    if (!Number.isFinite(this.drift)) this.drift = 0.002;
    if (!Number.isFinite(dt)) dt = 1;
    this.x -= this.drift * dt;
    if (!Number.isFinite(this.x)) {
      if (DEBUG) console.error("CRITICAL: Cloud X became NaN immediately after update! Was:", this.x);
      this.x = 0;
    }
  }

  draw(ctx, scrollX = 0, scrollY = 0) {
    if (!Number.isFinite(scrollX)) scrollX = 0;
    if (!Number.isFinite(scrollY)) scrollY = 0;

    const t = Math.max(0, Math.min(1, twilight));
    const hueShift = (1 - t) * 20;
    const lightness = 40 + t * 15;
    ctx.fillStyle = `hsl(${this.baseHue + hueShift}, 20%, ${lightness}%)`;

    for (const sq of this.squares) {
      ctx.fillStyle = `rgba(255,255,255,${sq.alpha})`;
      ctx.fillRect(
        Math.floor(this.x + sq.x - scrollX),
        Math.floor(this.y + sq.y - scrollY),
        sq.size,
        sq.size
      );
    }
  }
}

// ‚îÄ‚îÄ‚îÄ CLOUDS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let clouds = [];
let nextCloudSpawnX = 320; // start at right edge of canvas

// Create initial clouds
// console.log("Creating initial clouds...");
for (let i = 0; i < 3; i++) {
  const x = 50 + i * 100 + Math.random() * 30;
  const y = 30 + Math.random() * 30;
  // console.log(`Creating cloud ${i}: x=${x}, y=${y}`);
  
  const cloud = new Cloud(
    x,
    y,
    70 + Math.random() * 60,
    20 + Math.random() * 20,
    22,
    240 + Math.random() * 20
  );
  
  // console.log(`Created cloud ${i}: x=${cloud.x}, y=${cloud.y}`);
  clouds.push(cloud);
}
// console.log("Initial clouds created. Count:", clouds.length);

function updateCloudSpawning(playerWorldX) {
  if (!Number.isFinite(playerWorldX)) return;
  if (!Number.isFinite(nextCloudSpawnX)) nextCloudSpawnX = playerWorldX + 320;

  // Spawn clouds ahead of player in world space
  const spawnAhead = playerWorldX + 320 + 100; // player position + canvas width + padding

  while (nextCloudSpawnX < spawnAhead) {
    clouds.push(
      new Cloud(
        nextCloudSpawnX + Math.random() * 50,
        30 + Math.random() * 30, // higher in sky
        70 + Math.random() * 60,
        20 + Math.random() * 20,
        22,
        240 + Math.random() * 20
      )
    );

    nextCloudSpawnX += 80 + Math.random() * 120; // Smaller spacing
  }
  
  // Clouds are permanent - no removal needed
  
  // Debug check
  if (frameCount % 60 === 0) {
    // console.log("cloud count:", clouds.length, "playerX:", playerX, "nextCloudSpawnX:", nextCloudSpawnX);
  }
}

function updateClouds(dt) {
  clouds.forEach(c => c.update(dt));
}

function drawClouds(){
  clouds.forEach((c, index) => {
    c.draw(ctx, playerX * 0.3, 0);
  });
}

// ‚îÄ‚îÄ‚îÄ BUILDING WINDOWS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const windows = [
  {x:240, y:70, size:12, timer:detRandom()*200, hueOffset:0, alpha: 0.55},
  {x:260, y:70, size:12, timer:detRandom()*200, hueOffset:10, alpha: 0.55},
  {x:280, y:70, size:12, timer:detRandom()*200, hueOffset:-10, alpha: 0.55},
  {x:240, y:90, size:12, timer:detRandom()*200, hueOffset:5, alpha: 0.55},
  {x:260, y:90, size:12, timer:detRandom()*200, hueOffset:-5, alpha: 0.55},
];

// ‚îÄ‚îÄ‚îÄ STREET LAMPS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const lampPositions = [180, 340, 500, 660, 820];

// We'll calculate second lamp positions in initDock()
let allLampPositions = [];

// Initialize lamp breathing and wobble data after positions are calculated
let lampBreaths = [];

// ‚îÄ‚îÄ‚îÄ LEVEL END POSITION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Will be calculated after dock is initialized
let levelEndX = 0;
let maxPlayerX = 0; // ‚Üê ADD THIS LINE - Will be set after dock initializes

// ‚îÄ‚îÄ‚îÄ STREET SIGN ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const streetSign = {
  x: 420,
  y: 127,
  poleHeight: 20,
  signWidth: 4,
  signHeight: 8,
  colorPole: "#9a8c98"
};

// ‚îÄ‚îÄ‚îÄ TWILIGHT FIELD LINE (GRASS) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const fieldLine = {
  xStart: 400,
  yBase: 126,
  width: 800, // Extended to 800px (was 720)
  grassColor: C.fence,
  blades: []
};

// ‚îÄ‚îÄ‚îÄ SPAWN SEAGULLS IN WATER AFTER DOCK ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const seagulls = [];

// Function to initialize seagulls at the correct position (called after dock is initialized)
function initSeagulls() {
  // Calculate dock end position
  const dockEndX = DOCK_CONFIG.startX + DOCK_CONFIG.length;
  // Position seagulls 30px AFTER the dock end (was 20px, now +10px more)
  const seagullStartX = dockEndX + 30;
  
  for (let i = 0; i < 3; i++) {
    const x = seagullStartX + i * 35; // Spread 35px apart (was 25, more room now)
    const y = DOCK_CONFIG.waterLevel; // Right on water surface (130)
    seagulls.push(new FloatingSeagull(x, y));
  }
}

// ‚îÄ‚îÄ‚îÄ RADIO TOWER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const RADIO_TOWER_OFFSET = -200;

const radioTower = {
  x: lampPositions[lampPositions.length - 1] + RADIO_TOWER_OFFSET,
  yBase: 55
};

// Generate grass blades
const grassBladeCount = Math.ceil(fieldLine.width / 4);
const grassRandomValues = Array.from({length: grassBladeCount}, () => ({
  isFlower: detRandom() < 0.1,
  height: 4 + Math.floor(detRandom()*5),
  sway: detRandom()*0.3
}));

for(let i = 0; i < grassBladeCount; i++) { 
  const rand = grassRandomValues[i];
  fieldLine.blades.push({
    x: fieldLine.xStart + i * 4,
    height: rand.height,
    sway: rand.sway,
    isFlower: rand.isFlower
  });
}

// ‚îÄ‚îÄ‚îÄ AUDIO ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Lazy accessor: returns the shared, resumed AudioContext (created on first user gesture)
function getAudioCtx() {
  if (!window.audioCtx) {
    window.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  if (window.audioCtx.state === 'suspended') window.audioCtx.resume();
  return window.audioCtx;
}

// ‚îÄ‚îÄ‚îÄ CAT MEOW SOUND ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function playCatMeow(pitchMult = 1.0, bursts = 1) {
  const ctx = getAudioCtx();
  
  for (let b = 0; b < bursts; b++) {
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();

    // --- Soft tone / longer duration ---
    let startFreq = 800;     // starting pitch
    let endFreq = 500;       // pitch drops more slowly
    const duration = 1.2;      // total meow length in seconds

    // Apply pitch multiplier for whistle interactions
    if (pitchMult !== 1.0) {
      startFreq *= pitchMult;
      endFreq *= pitchMult;
    }

    osc.type = 'sine';         // soft sine wave
    osc.frequency.setValueAtTime(startFreq, ctx.currentTime + b * 0.08);

    // --- Descending pitch with wobble at the end ---
    osc.frequency.linearRampToValueAtTime(endFreq, ctx.currentTime + b * 0.08 + duration * 0.7);
    
    // Wobble / subtle vibrato for last 30% of the meow
    const wobbleStart = ctx.currentTime + b * 0.08 + duration * 0.7;
    const wobbleEnd = ctx.currentTime + b * 0.08 + duration;
    const wobble = osc.frequency;  
    wobble.setValueAtTime(endFreq, wobbleStart);

    // Add slight vibrato
    const vibrato = ctx.createOscillator();
    const vibrGain = ctx.createGain();
    vibrato.frequency.value = 8;       // 8 Hz wobble
    vibrGain.gain.value = 8;           // +/- 8 Hz
    vibrato.connect(vibrGain);
    vibrGain.connect(osc.frequency);
    vibrato.start(wobbleStart);
    vibrato.stop(wobbleEnd);

    // --- Gain envelope for soft fade ---
    gain.gain.setValueAtTime(0, ctx.currentTime + b * 0.08);
    gain.gain.linearRampToValueAtTime(0.08, ctx.currentTime + b * 0.08 + 0.05); // reduced from 0.15
    gain.gain.linearRampToValueAtTime(0.025, ctx.currentTime + b * 0.08 + duration * 0.8); // reduced from 0.05
    gain.gain.linearRampToValueAtTime(0, ctx.currentTime + b * 0.08 + duration); // end

    osc.connect(gain);
    gain.connect(ctx.destination);

    osc.start();
    osc.stop(ctx.currentTime + b * 0.08 + duration + 0.05);
  }
}

// console.log('Refined cat meow synthesis system ready');

// ===== PINK NOISE GENERATOR (Voss-McCartney algorithm - perfect for rain) =====
function generatePinkNoise(length, sampleRate) {
  const buffer = new AudioBuffer({ numberOfChannels: 1, length, sampleRate });
  const data = buffer.getChannelData(0);
  
  let b0 = b1 = b2 = b3 = b4 = b5 = b6 = 0;
  let white;
  
  // Small random offset to phase each time we generate (reduces repeating pattern feel)
  const phaseOffset = Math.random() * 0.02 - 0.01;
  
  for (let i = 0; i < length; i++) {
    white = Math.random() * 2 - 1;
    
    b0 = 0.99886 * b0 + white * 0.0555179;
    b1 = 0.99332 * b1 + white * 0.0750759;
    b2 = 0.96900 * b2 + white * 0.1538520;
    b3 = 0.86650 * b3 + white * 0.3104856;
    b4 = 0.55000 * b4 + white * 0.5329522;
    b5 = -0.7616 * b5 - white * 0.1843094;
    
    let pink = (b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * phaseOffset) * 0.11;
    
    // Tiny extra white noise layer (0.5‚Äì2% mix) ‚Üí masks any remaining loop artifacts
    const extraWhiteMix = 0.008 + Math.random() * 0.012;
    pink += white * extraWhiteMix;
    
    // Soft clip to prevent rare harsh peaks
    pink = Math.max(-1, Math.min(1, pink));
    
    data[i] = pink;
    b6 = white * 0.115926;
  }
  
  return buffer;
}

// Toggle with R key - UNIFIED SMOOTH RAIN SYSTEM
window.addEventListener("keydown", (e) => {
  if (e.key.toLowerCase() === "s") {
    spawnPlayerShootingStar();
    e.preventDefault();
  }
});

// console.log('Procedural rain sound system ready');

// ‚îÄ‚îÄ‚îÄ GOOSE HONK SOUND ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ü™ø Synthesized Goose Honk (Web Audio API)
function playGooseHonk(volume = 0.2, pitchVariation = 0) {
    const audioCtx = getAudioCtx();
    const now = audioCtx.currentTime;

    // Oscillator (goose throat tone)
    const osc = audioCtx.createOscillator();
    osc.type = "sawtooth";
    osc.frequency.setValueAtTime(360 + pitchVariation, now);
    osc.frequency.exponentialRampToValueAtTime(260 + pitchVariation, now + 0.25);

    // Gain envelope
    const gain = audioCtx.createGain();
    gain.gain.setValueAtTime(0.0001, now);
    gain.gain.exponentialRampToValueAtTime(volume, now + 0.04);
    gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.28);

    // Low-pass filter (distance + softness)
    const filter = audioCtx.createBiquadFilter();
    filter.type = "lowpass";
    filter.frequency.setValueAtTime(1200, now);

    // Subtle wobble (natural goose voice)
    const lfo = audioCtx.createOscillator();
    const lfoGain = audioCtx.createGain();
    lfo.frequency.value = 6;       // slow wobble
    lfoGain.gain.value = 18;       // pitch variation

    lfo.connect(lfoGain);
    lfoGain.connect(osc.frequency);

    // Chain
    osc.connect(filter);
    filter.connect(gain);
    gain.connect(audioCtx.destination);

    // Start / stop
    lfo.start(now);
    osc.start(now);
    osc.stop(now + 0.3);
    lfo.stop(now + 0.3);
}

// Distance-based volume calculation
function distanceVolume(sourceX, playerX, maxDistance = 320) {
    const distance = Math.abs(sourceX - playerX);
    const volume = Math.max(0, 1 - (distance / maxDistance));
    return volume * 0.2; // Scale to max goose volume
}

// if (DEBUG) console.log('Goose honk synthesis system ready');

// ‚îÄ‚îÄ‚îÄ GOOSE EVENT STATE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Radio tower is at X=620, so geese start at X=1560 (900px further right)
const geese = [
  { x: 1560, y: 120, state: "idle", delay: 0, angle: -0.4, phase: 0, bob: 0, pitchVar: 0 },
  { x: 1585, y: 120, state: "idle", delay: 20, angle: -0.2, phase: 1.5, bob: 0, pitchVar: 20 }, // 25px gap (closer)
  { x: 1630, y: 120, state: "idle", delay: 40, angle:  0.1, phase: 3.1, bob: 0, pitchVar: -15 }  // 45px gap (same as before)
];

// ‚îÄ‚îÄ‚îÄ OWL HOOT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let owlHooted = false;

// Owl hoot sequence
const owlSequence = [0, 0.5, 1, 1.5];
const owlDurations = [0.3, 0.3, 0.3, 0.5];

// ‚îÄ‚îÄ‚îÄ OWL HOOT FUNCTIONS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function playSingleOwlHoot(startTime, duration, frequency=220, volume=0.03){
  const audioCtx = getAudioCtx();
  const oscillator = audioCtx.createOscillator();
  const gainNode = audioCtx.createGain();

  oscillator.type = 'sine';
  oscillator.frequency.setValueAtTime(frequency, audioCtx.currentTime);

  gainNode.gain.setValueAtTime(0, startTime);
  gainNode.gain.linearRampToValueAtTime(volume, startTime + 0.05);
  gainNode.gain.linearRampToValueAtTime(0, startTime + duration);

  oscillator.connect(gainNode);
  gainNode.connect(audioCtx.destination);

  oscillator.start(startTime);
  oscillator.stop(startTime + duration);
}

function playOwlSequence(){
  const audioCtx = getAudioCtx();
  const now = audioCtx.currentTime;
  const baseFreq = 120 + Math.random()*10;
  const volume = 0.02;

  owlSequence.forEach((offset, i)=>{
    playSingleOwlHoot(now + offset, owlDurations[i], baseFreq, volume);
  });
  
  if (DEBUG) console.log("Owl sequence played!");
}

// ===== SCHEDULE INITIAL EVENTS =====
function scheduleInitialEvents() {
    scheduleEvent(950, () => {
        ufoTriggered = true;
        ufo.active = true;
        ufo.x = 600;
        ufo.y = fieldLine.yBase - 20;
        ufo.alpha = 0.8;
        // if (DEBUG) console.log("üõ∏ UFO triggered via event system");
    });
    
    scheduleEvent(700, () => {
        if (!owlHooted && stars.length > 0) {
            playOwlSequence();
            owlHooted = true;
            triggerGlidingSeagull(); // Spawn gliding seagull when owl hoots
        }
    }, false);
    
    scheduleEvent(levelEndX - 50, () => {
        if (twilight > 0.7) {
            for (let i = 0; i < 3; i++) {
                shootingStars.push({
                    x: detRandom() * W,
                    y: detRandom() * 30,
                    length: 2 + Math.floor(detRandom() * 3),
                    speed: 3 + detRandom() * 2,
                    alpha: 1
                });
            }
        }
    });
}

// ‚îÄ‚îÄ‚îÄ FOOTSTEP SYSTEM ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

// Config
const FOOTSTEP_DISTANCE = 8; // pixels the player must walk before next footstep

// State
let lastFootstepX = playerX;  // track where the last footstep triggered

// Clean function to determine surface
function getFootstepSurface() {
    return isPlayerOnDock() ? "dock" : "road";
}

// Clean dock check
function isPlayerOnDock() {
    const playerFeetX = playerX + 60; // adjust to player's feet
    const dockStartX = DOCK_CONFIG.startX;
    const dockEndX = DOCK_CONFIG.startX + DOCK_CONFIG.length;
    const playerFeetY = 125; // bottom of player sprite
    const dockTopY = DOCK_CONFIG.waterLevel - DOCK_CONFIG.plankHeight;

    return playerFeetX >= dockStartX &&
           playerFeetX <= dockEndX &&
           playerFeetY >= dockTopY;
}

// Play footstep sound
function playFootstep(surface) {
    const audioCtx = window.audioCtx || new (window.AudioContext || window.webkitAudioContext)();
    window.audioCtx = audioCtx;
    
    // Resume AudioContext if suspended (browser security)
    if (audioCtx.state === 'suspended') {
        audioCtx.resume();
    }
    
    const now = audioCtx.currentTime;

    const bufferSize = audioCtx.sampleRate * 0.05;
    const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
    const data = buffer.getChannelData(0);

    for (let i = 0; i < bufferSize; i++) {
        data[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize);
    }

    const source = audioCtx.createBufferSource();
    source.buffer = buffer;

    const filter = audioCtx.createBiquadFilter();
    const gain = audioCtx.createGain();

    if (surface === "dock") {
        filter.type = "bandpass";
        filter.frequency.value = 650;
        gain.gain.value = 0.05; // increased from 0.033
    } else {
        filter.type = "lowpass";
        filter.frequency.value = 600;
        gain.gain.value = 0.045; // increased from 0.03
    }

    source.connect(filter);
    filter.connect(gain);
    gain.connect(audioCtx.destination);
    source.start();
}

// ‚îÄ‚îÄ‚îÄ UPDATE FOOTSTEPS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function updateFootsteps() {
    const distance = Math.abs(playerX - lastFootstepX);

    if (distance >= FOOTSTEP_DISTANCE) {
        const surface = getFootstepSurface();
        playFootstep(surface);
        lastFootstepX = playerX; // reset for next step
    }
}

// ‚îÄ‚îÄ‚îÄ INPUT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
window.addEventListener("keydown", () => {
  getAudioCtx(); // ensure context exists and is resumed on first keypress
}, {once:true});

window.addEventListener("keydown", e => {
  keys[e.key] = true;
  
  // Title screen input handling
  if (gameState === 'title' && 
      (e.key === 'ArrowLeft' || e.key === 'ArrowRight' || 
       e.key.toLowerCase() === 'a' || e.key.toLowerCase() === 'd')) {
    startGameFade();
    e.preventDefault();
  }
  
  // Rain cycle on R key
  if (e.key.toLowerCase() === 'r') {
    rainLevel = (rainLevel + 1) % 4;   // 0 ‚Üí 1 ‚Üí 2 ‚Üí 3 ‚Üí 0
    rainTarget = rainLevel / 3;
    
    // Rain audio is initialized once in initializeGame() and updated automatically in update loop
    
    // Rain audio is now handled automatically by updateRainAudio() in the update loop
    if (DEBUG) console.log(`Rain level: ${rainLevel} (${['Off', 'Light', 'Heavy', 'Very Heavy'][rainLevel]})`);
    e.preventDefault();
  }
  
  // Moon toggle on M key
  if (e.key.toLowerCase() === "m") {
    moonVisible = !moonVisible;
  }
  
  // Moon phase cycle on N key
  if (e.key.toLowerCase() === "n") {
    lastMoonPhase = moonPhase;
    moonPhase = (moonPhase + 1) % MOON_PHASE_COUNT;
    moonBlend = 0; // Reset blend for smooth transition
  }
  
  // Whistle on W key press
  if (e.key === "w" || e.key === "W") {
    playWhistle();
  }
});
window.addEventListener("keyup", e=>keys[e.key]=false);

// ‚îÄ‚îÄ‚îÄ HELPERS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function lerpColor(a,b,t){
  const ah=parseInt(a.slice(1),16), bh=parseInt(b.slice(1),16);
  const ar=(ah>>16)&0xff, ag=(ah>>8)&0xff, ab=ah&0xff;
  const br=(bh>>16)&0xff, bg=(bh>>8)&0xff, bb=bh&0xff;
  const rr=Math.round(ar+(br-ar)*t);
  const rg=Math.round(ag+(bg-ag)*t);
  const rb=Math.round(ab+(bb-ab)*t);
  return `rgb(${rr},${rg},${rb})`;
}

// ‚îÄ‚îÄ‚îÄ ATMOSPHERIC WASH ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function drawAtmosphericWash(ctx) {
  if (!moonVisible) return;
  
  // Use current phase wash directly (rgba colors don't need interpolation for subtle effect)
  ctx.fillStyle = MOON_COLORS[moonPhase].wash;
  ctx.fillRect(0, 0, W, H);
}

// ===== ENHANCED NIGHT EFFECTS FUNCTIONS =====
function updateNightEffects() {
    NIGHT_EFFECTS.fogAlpha = Math.max(0, (twilight - 0.5) * 0.6);
    NIGHT_EFFECTS.silhouetteAlpha = 0.2 * twilight;
    NIGHT_EFFECTS.windowGlowMultiplier = 1.0 + twilight * 0.5;
}

function drawNightFog() {
    if (NIGHT_EFFECTS.fogAlpha <= 0) return;
    
    const alpha = NIGHT_EFFECTS.fogAlpha;
    
    const gradient = ctx.createRadialGradient(
        W/2, H * 0.7, 10,
        W/2, H * 0.7, 150
    );
    gradient.addColorStop(0, `rgba(20, 20, 40, ${alpha * 0.3})`);
    gradient.addColorStop(1, `rgba(20, 20, 40, ${alpha})`);
    
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, W, H);
}

function drawDistantSilhouettes() {
    if (NIGHT_EFFECTS.silhouetteAlpha <= 0) return;
    
    ctx.globalAlpha = NIGHT_EFFECTS.silhouetteAlpha;
    
    NIGHT_EFFECTS.distantHills.forEach(hill => {
        const parallaxX = hill.x - playerX * 0.1;
        ctx.fillStyle = hill.color;
        ctx.fillRect(parallaxX, H - 60 - hill.height, hill.width, hill.height);
    });
    
    ctx.globalAlpha = 1;
}

// ===== DOCK & WATER FUNCTIONS =====
function updateDock(dt = 1/60) {
    waterRippleOffset += DOCK_CONFIG.waterRippleSpeed * dt * 60; // Frame-rate independent
    
    dockPoles.forEach(pole => {
        pole.swayPhase += pole.swaySpeed * dt * 60; // Frame-rate independent
        pole.y = pole.baseY + Math.sin(pole.swayPhase) * pole.swayAmplitude;
    });
}

// FIXED: Draw water with consistent 0.7 parallax
function drawWater() {
    const waterStartX = DOCK_CONFIG.startX - 100; // Water starts before the dock
    const waterEndX = DOCK_CONFIG.startX + 2000; // Extend water far to the right (2000px total)
    
    const waterY = DOCK_CONFIG.waterLevel;
    
    // Draw water area - this REPLACES the road under the dock
    for (let y = 0; y < DOCK_CONFIG.waterHeight; y += 2) {
        for (let x = waterStartX; x < waterEndX; x += 2) {
            // Calculate ripple
            const ripple = Math.sin(waterRippleOffset + x * 0.1 + y * 0.05) * DOCK_CONFIG.waterRippleAmplitude;
            const blueTint = 30 + ripple;
            
            // Gradient from darker at bottom to lighter at top
            const depthFactor = 1 - (y / DOCK_CONFIG.waterHeight);
            const r = Math.floor(40 * depthFactor);
            const g = Math.floor(60 * depthFactor);
            const b = Math.floor(100 + blueTint * depthFactor);
            
            ctx.fillStyle = `rgb(${r},${g},${b})`;
            // FIXED: Changed from 0.5 to 0.7 to match dock parallax
            ctx.fillRect(x - playerX * 0.7, waterY + y, 2, 2);
        }
    }
    
    // Moon reflection - only draw over water area
    const reflectionAlpha = 0.2 + 0.1 * Math.sin(frameCount / 100);
    ctx.fillStyle = DOCK_CONFIG.moonReflectionColor.replace('0.3', reflectionAlpha.toString());
    
    const reflectionSteps = 8;
    for (let i = 0; i < reflectionSteps; i++) {
        const t = i / (reflectionSteps - 1);
        const y = waterY + t * DOCK_CONFIG.moonReflectionHeight;
        const height = Math.max(1, Math.floor(DOCK_CONFIG.moonReflectionHeight / reflectionSteps));
        const alpha = reflectionAlpha * (1 - t * 0.7);
        
        ctx.fillStyle = `rgba(255,255,220,${alpha})`;
        // FIXED: Changed from 0.5 to 0.7 to match dock parallax
        ctx.fillRect(
            DOCK_CONFIG.moonX - DOCK_CONFIG.moonReflectionWidth/2 - playerX * 0.7,
            y,
            DOCK_CONFIG.moonReflectionWidth,
            height
        );
    }
}

// MODIFIED: Draw dock OVER the water
function drawDock() {
    const dockStartX = DOCK_CONFIG.startX - playerX * 0.7;
    const dockEndX = DOCK_CONFIG.startX + DOCK_CONFIG.length - playerX * 0.7;
    
    // Draw dock planks with variation (OVER the water)
    for (let x = 0; x < DOCK_CONFIG.length; x += 8) {
        const shade = detRandom() < 0.5 ? 1 : 0.92;
        ctx.fillStyle = `rgba(91,86,104,${shade})`;
        ctx.fillRect(
            DOCK_CONFIG.startX + x - playerX * 0.7,
            DOCK_CONFIG.waterLevel - DOCK_CONFIG.plankHeight,
            6,
            DOCK_CONFIG.plankHeight
        );
    }
    
   
    // Draw dock poles
    let firstDockPoleScreen = null;
    
    dockPoles.forEach(pole => {
        const poleX = pole.x - playerX * 0.7;
        const poleTop = pole.y - pole.height;

        if (!firstDockPoleScreen) {
            firstDockPoleScreen = { x: poleX, y: poleTop };
        }

        // Draw pole
        ctx.fillStyle = DOCK_CONFIG.dockPoleColor;
        ctx.fillRect(
            poleX - DOCK_CONFIG.dockPoleWidth / 2,
            poleTop,
            DOCK_CONFIG.dockPoleWidth,
            pole.height
        );
    });
    
    // Wire from last telephone pole to first dock pole
    if (firstDockPoleScreen) {
        const lastPoleX = secondLampPositions[secondLampPositions.length - 1] - playerX * 0.7;
        const lastPoleY = lampY;

        drawSlackWire(
            lastPoleX,
            lastPoleY,
            firstDockPoleScreen.x,
            firstDockPoleScreen.y,
            5
        );
    }
    
    // Add smaller pole lamp at dock end - only if valid pole exists
    const lastDockPole = dockPoles[dockPoles.length - 1];
    if (lastDockPole && lastDockPole.x > DOCK_CONFIG.startX) {
        const lampX = lastDockPole.x - playerX * 0.7;
        const lampBaseY = lastDockPole.y - lastDockPole.height;

        // Draw the original lamp
        drawPoleLamp(lampX, lampBaseY + 2, 0.85);
        
        // Add subtle glow positioned exactly at the lamp light pixel location
        // From drawPoleLamp: lamp light is at x + armLength + 1, poleTop + 7
        const scale = 0.85;
        const armLength = Math.floor(6 * scale);
        const poleHeight = Math.floor(34 * scale);
        const poleTop = lampBaseY + 2 - poleHeight;
        
        // Exact lamp tip coordinates matching drawPoleLamp
        const lampTipX = lampX + armLength + 1;
        const lampTipY = poleTop + 7;
        
        drawDockLampGlow(lampTipX, lampTipY, 0, 0); // No offsets needed since we have exact position
    }
}

// FIXED: Draw street with consistent screen space logic
function drawStreet(){
    const dockScreenX = ~~(DOCK_CONFIG.startX - playerX * 0.7);
    
    if (dockScreenX > 0) {
        ctx.fillStyle = C.street;
        // Stop 3px before dock transition to leave space for the edge
        ctx.fillRect(0, 130, Math.min(W, dockScreenX - 3), 50);
    }
}

// FIXED: Draw sidewalk with consistent screen space logic
function drawSidewalk(){
    const dockScreenX = ~~(DOCK_CONFIG.startX - playerX * 0.7);
    
    if (dockScreenX > 0) {
        ctx.fillStyle = C.sidewalk;
        // Stop 3px before dock transition to leave space for the edge
        ctx.fillRect(0, 125, Math.min(W, dockScreenX - 3), 10);
    }
}

function drawDockTransition() {
    const edgeX = DOCK_CONFIG.startX - playerX * 0.7;

    // Sidewalk edge shadow
    ctx.fillStyle = "rgba(0,0,0,0.25)";
    ctx.fillRect(edgeX - 2, 125, 2, 10);

    // Vertical dock edge / curb face
    ctx.fillStyle = "#3b3f5c"; // cooler sidewalk edge tone
    ctx.fillRect(edgeX, 125, 1, 15);

    // Subtle wear lines
    ctx.fillStyle = "rgba(255,255,255,0.08)";
    for (let y = 127; y < 138; y += 3) {
        ctx.fillRect(edgeX, y, 1, 1);
    }
}

function drawPoleLamp(x, baseY, scale = 1) {
    const poleHeight = Math.floor(34 * scale);
    const armLength = Math.floor(6 * scale);

    const poleTop = baseY - poleHeight;

    // Pole
    ctx.fillStyle = C.pole;
    ctx.fillRect(
        x - 1,
        poleTop,
        2,
        poleHeight
    );

    // Arm
    ctx.fillRect(
        x,
        poleTop + 6,
        armLength,
        1
    );

    // Lamp housing
    ctx.fillStyle = C.lampDark;
    ctx.fillRect(
        x + armLength,
        poleTop + 6,
        3,
        3
    );

    // Lamp light pixel
    ctx.fillStyle = C.lampLight;
    ctx.fillRect(
        x + armLength + 1,
        poleTop + 7,
        1,
        1
    );
}

// ‚îÄ‚îÄ‚îÄ SKY ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function drawSky(){
  const skyColorsTop = ["#7e75a6","#73679a","#6d597a","#5c5f86"];
  const skyColorsMid = ["#4a4e69","#3f425f","#343758","#2b2d42"];
  const skyColorsBottom = ["#2b2d42","#1e1f35","#1b1b2b","#191924","#15151d"];
  const allColors = skyColorsTop.concat(skyColorsMid, skyColorsBottom);

  let yStart = 0;
  const totalBands = allColors.length;

  for (let i = totalBands - 1; i >= 0; i--) {
    const bandHeight = Math.ceil(H / totalBands * (1 - i*0.05));
    const baseColor = lerpColor(allColors[i], allColors[i], twilight);
    const prevColor = i < totalBands - 1 ? lerpColor(allColors[i+1], allColors[i+1], twilight) : baseColor;
    const nextColor = i > 0 ? lerpColor(allColors[i-1], allColors[i-1], twilight) : baseColor;

    ctx.fillStyle = baseColor;
    ctx.fillRect(0, yStart, W, bandHeight);

    for (let dy = 0; dy < 2; dy++) {
      for (let dx = 0; dx < W; dx++) {
        if (staticDither[yStart+dy] && staticDither[yStart+dy][dx] && (dx > 0 || dy > 0)) {
          ctx.fillStyle = prevColor;
          ctx.fillRect(dx, yStart + dy, 1, 1);
        }
      }
    }

    for (let dy = bandHeight - 2; dy < bandHeight; dy++) {
      if (yStart + dy >= H) continue;
      for (let dx = 0; dx < W; dx++) {
        if (staticDither[yStart+dy] && staticDither[yStart+dy][dx] && (dx > 0 || dy > 0)) {
          ctx.fillStyle = nextColor;
          ctx.fillRect(dx, yStart + dy, 1, 1);
        }
      }
    }

    yStart += bandHeight;
  }
}


// ‚îÄ‚îÄ‚îÄ MOON BUFFER RENDERING ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Helper: get solid width per row
function getMoonRowBounds(row) {
  let left = row.indexOf("#");
  let right = row.lastIndexOf("#");
  return { left, right };
}

function drawMoonSparkles(ctx) {
  // Micro twinkle life - very subtle hold
  if (moonSparkleLife > 0) {
    moonSparkleLife--;
    return;
  }

  // Very rare chance per frame
  if (Math.random() > 0.01) return;

  moonSparkleLife = 6;

  // Pick a random solid moon pixel
  const y = Math.floor(Math.random() * MOON_PIXELS.length);
  const row = MOON_PIXELS[y];
  const { left, right } = getMoonRowBounds(row);
  if (left === -1) return;

  const x = left + Math.floor(Math.random() * (right - left));

  // Avoid drawing exactly at (0,0) to prevent corner pixel
  if (x >= 1 && y >= 1) {
    ctx.fillStyle = MOON_SPARKLE_COLOR;
    drawDot(x, y, MOON_SPARKLE_COLOR);
  }
}

function updateMoonBuffer() {
  renderMoonToBuffer();      // base moon + spots
  drawMoonSparkles(moonCtx); // ‚ú® sparkles
  applyMoonPhaseToBuffer();  // mask LAST
}

function renderMoonToBuffer() {
  moonCtx.clearRect(0, 0, 17, 17);

  // Get phase-specific colors
  const phaseColors = MOON_COLORS[moonPhase];
  
  // Draw atmospheric wash first (subtle background glow)
  moonCtx.fillStyle = phaseColors.wash;
  moonCtx.fillRect(0, 0, 17, 17);

  // Draw moon body with desaturated base
  moonCtx.fillStyle = phaseColors.base;
  MOON_PIXELS.forEach((row, y) => {
    [...row].forEach((p, x) => {
      if (p === "#") {
        moonCtx.fillRect(x, y, 1, 1);
      }
    });
  });

  // Draw moon spots with darker, material-based color
  moonCtx.fillStyle = 'rgba(180,180,185,0.6)';
  moonCtx.fillRect(5, 5, 2, 2);
  moonCtx.fillRect(10, 6, 2, 2);
  moonCtx.fillRect(7, 10, 3, 2);

  // Full moon crater smile + double blink (darker, wider grin, dual eye colors)
  if (moonPhase === MOON_PHASES.FULL && fullMoonSmileActive && fullMoonSmileFrame > 0) {
    const fade = Math.min(1, fullMoonSmileTimer / 60);
    const alpha = 0.28 * fade;           // slightly higher base opacity for darker feel

    // Darker crater palette
    const craterBase   = `rgba(120, 120, 140, ${alpha})`;      // deep cool gray
    const eyeLeftColor = `rgba(160, 140, 100, ${alpha * 1.1})`; // warm yellowish
    const eyeRightColor= `rgba(100, 140, 180, ${alpha * 1.1})`; // cool bluish
    const smileColor   = `rgba(90, 90, 110, ${alpha * 0.95})`;  // darker smile
    const highlight    = `rgba(220, 220, 240, ${alpha * 0.35})`; // subtle gleam

    // Wider grin (spans more of the lower crater area)
    moonCtx.fillStyle = smileColor;
    moonCtx.fillRect(5, 11, 8, 1);          // wider main smile line
    moonCtx.fillRect(6, 10, 6, 1);          // upper curve ‚Äî more pronounced
    moonCtx.fillRect(7, 12, 4, 1);          // subtle downward ends ‚Äî cheeky grin

    // Eyes ‚Äî different colors, positioned wider apart
    if (fullMoonSmileFrame !== 2 && fullMoonSmileFrame !== 3) { // eyes open
      moonCtx.fillStyle = eyeLeftColor;
      moonCtx.fillRect(5, 6, 2, 2);         // left eye (warmer)
      moonCtx.fillStyle = eyeRightColor;
      moonCtx.fillRect(10, 6, 2, 2);        // right eye (cooler)
    }

    // Double blink sequence (frames 2 & 3 = quick close-open-close)
    if (fullMoonSmileFrame === 2 || fullMoonSmileFrame === 3) {
      // During blink: eyes closed (just dark craters)
      moonCtx.fillStyle = craterBase;
      moonCtx.fillRect(5, 6, 2, 2);         // left eye closed
      moonCtx.fillRect(10, 6, 2, 2);        // right eye closed
    }

    // Gleam only on open eyes
    if (fullMoonSmileFrame !== 2 && fullMoonSmileFrame !== 3) {
      moonCtx.fillStyle = highlight;
      moonCtx.fillRect(5.5, 6.5, 0.8, 0.8);   // left gleam
      moonCtx.fillRect(10.5, 6.5, 0.8, 0.8);  // right gleam
    }
  }

  // New moon evil face + slow wink (drawn before phase mask)
  if (moonPhase === MOON_PHASES.NEW && newMoonEvilWinkActive && newMoonEvilWinkFrame > -1) {
    const fade = Math.min(1, newMoonEvilWinkTimer / 120); // slower fade-out
    const alpha = 0.42 * fade;  // higher contrast than full moon version

    // Cold, sinister palette ‚Äî darker with faint reddish-purple menace
    const eyeColor     = `rgba(100,  60,  80, ${alpha})`;      // deep purple-gray
    const slitColor    = `rgba( 60,  30,  50, ${alpha * 1.1})`; // even darker for wink slit
    const smileColor   = `rgba( 90,  50,  70, ${alpha * 0.9})`; // cruel smirk
    const highlight    = `rgba(220, 180, 200, ${alpha * 0.25})`; // cold gleam

    // Eyes ‚Äî sharper, more intense
    moonCtx.fillStyle = eyeColor;
    moonCtx.fillRect(5,  6, 2, 2);  // left eye ‚Äî square & glaring
    if (newMoonEvilWinkFrame === 0 || newMoonEvilWinkFrame === 2) {
      moonCtx.fillRect(10, 6, 2, 2); // right eye open (intense stare)
    } else {
      // Evil wink: right eye becomes narrow vertical slit
      moonCtx.fillStyle = slitColor;
      moonCtx.fillRect(11, 7, 1, 1); // thin slit
    }

    // Tiny cold gleam on open eyes
    if (newMoonEvilWinkFrame !== 1) {
      moonCtx.fillStyle = highlight;
      moonCtx.fillRect(5.5, 6.5, 0.8, 0.8);  // left eye gleam
      moonCtx.fillRect(10.5, 6.5, 0.8, 0.8); // right eye gleam (when open)
    }

    // Smile ‚Äî narrower, sharper, more like a sneer/smirk
    moonCtx.fillStyle = smileColor;
    moonCtx.fillRect(6, 11, 5, 1);          // main line ‚Äî flatter & cruel
    moonCtx.fillRect(7, 12, 3, 1);          // downward curve at ends ‚Äî mocking
  }
}

function applyMoonPhaseToBuffer() {
  moonCtx.save();
  moonCtx.globalCompositeOperation = "destination-out";

  MOON_PIXELS.forEach((row, y) => {
    const { left, right } = getMoonRowBounds(row);
    if (left === -1) return;

    const width = right - left + 1;

    switch (moonPhase) {
      case MOON_PHASES.NEW:
        moonCtx.fillRect(left, y, width, 1);
        break;

      case MOON_PHASES.WAXING_CRESCENT:
        moonCtx.fillRect(left, y, Math.floor(width * 0.65), 1);
        break;

      case MOON_PHASES.FIRST_QUARTER:
        moonCtx.fillRect(left, y, Math.floor(width * 0.5), 1);
        break;

      case MOON_PHASES.WAXING_GIBBOUS:
        moonCtx.fillRect(left, y, Math.floor(width * 0.25), 1);
        break;

      case MOON_PHASES.FULL:
        // no mask ‚Äî intentionally empty
        break;

      case MOON_PHASES.WANING_GIBBOUS:
        moonCtx.fillRect(left + Math.floor(width * 0.75), y, Math.ceil(width * 0.25), 1);
        break;

      case MOON_PHASES.LAST_QUARTER:
        moonCtx.fillRect(left + Math.floor(width * 0.5), y, Math.ceil(width * 0.5), 1);
        break;

      case MOON_PHASES.WANING_CRESCENT:
        moonCtx.fillRect(left + Math.floor(width * 0.35), y, Math.ceil(width * 0.65), 1);
        break;
    }
  });

  moonCtx.restore();
}

// ‚îÄ‚îÄ‚îÄ MOON FACE DRAWING FUNCTIONS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üåë ANGRY NEW MOON FACE (CLEAN + CENTERED)
function drawAngryMoonFace(ctx, cx, cy, r, t) {
  const pulse = Math.sin(t * 0.15) * 0.5;

  ctx.strokeStyle = 'rgba(140, 80, 80, 0.95)';
  ctx.lineWidth = 1.5;
  ctx.shadowColor = 'rgba(0,0,0,0.4)';
  ctx.shadowBlur = 2;

  // Eyes (slanted, inward)
  ctx.beginPath();
  ctx.moveTo(cx - r * 0.35, cy - r * 0.1);
  ctx.lineTo(cx - r * 0.15, cy - r * 0.15 - pulse);
  ctx.moveTo(cx + r * 0.35, cy - r * 0.1);
  ctx.lineTo(cx + r * 0.15, cy - r * 0.15 - pulse);
  ctx.stroke();

  // Mouth (tight arc)
  ctx.beginPath();
  ctx.arc(cx, cy + r * 0.25, r * 0.2, Math.PI, Math.PI * 2);
  ctx.stroke();
  
  ctx.shadowBlur = 0;
}

// üåï HAPPY FULL MOON FACE (SOFT + WARM)
function drawHappyMoonFace(ctx, cx, cy, r, t) {
  const bob = Math.sin(t * 0.08) * 0.8;

  ctx.strokeStyle = 'rgba(255, 255, 255, 0.95)';
  ctx.lineWidth = 1.5;
  ctx.shadowColor = 'rgba(0,0,0,0.35)';
  ctx.shadowBlur = 2;

  // Eyes (gentle curves)
  ctx.beginPath();
  ctx.arc(cx - r * 0.25, cy - r * 0.1 + bob, r * 0.08, Math.PI, 0);
  ctx.arc(cx + r * 0.25, cy - r * 0.1 + bob, r * 0.08, Math.PI, 0);
  ctx.stroke();

  // Smile
  ctx.beginPath();
  ctx.arc(cx, cy + r * 0.15, r * 0.25, 0, Math.PI);
  ctx.stroke();
  
  ctx.shadowBlur = 0;
}

// ‚îÄ‚îÄ‚îÄ MOON ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function drawMoon(ctx) {
  if (!moonVisible) return;
  
  const phase = MOON_COLORS[moonPhase];

  ctx.save();

  // 1Ô∏è‚É£ Halo first ‚Äî this is light interacting with darkness
  ctx.globalCompositeOperation = 'lighter';
  ctx.globalAlpha = 1;
  ctx.fillStyle = phase.halo;
  ctx.beginPath();
  ctx.arc(moonX, moonY, moonRadius * 1.7, 0, Math.PI * 2);
  ctx.fill();

  // 2Ô∏è‚É£ Secondary soft halo (depth, not brightness)
  ctx.globalAlpha = 0.4;
  ctx.beginPath();
  ctx.arc(moonX, moonY, moonRadius * 2.3, 0, Math.PI * 2);
  ctx.fill();

  // 3Ô∏è‚É£ Reset blending for solid object
  ctx.globalCompositeOperation = 'source-over';
  ctx.globalAlpha = 1;

  // 4Ô∏è‚É£ Moon disk (quiet, grounded, physical)
  ctx.fillStyle = phase.base;
  ctx.beginPath();
  ctx.arc(moonX, moonY, moonRadius, 0, Math.PI * 2);
  ctx.fill();

  // 5Ô∏è‚É£ Apply moon phase mask ON TOP of the cosmic moon
  applyPhaseMaskToCosmicMoon(ctx);

  // 6Ô∏è‚É£ Draw whistle faces ON TOP of the masked moon
  drawWhistleFacesOnCosmicMoon(ctx);

  // 7Ô∏è‚É£ Draw new centered face expressions
  if (moonFaceTimer > 0) {
    const cx = moonX;
    const cy = moonY;
    const r = moonRadius;

    if (moonFace === 'angry') {
      drawAngryMoonFace(ctx, cx, cy, r, moonFaceTimer);
    }

    if (moonFace === 'happy') {
      drawHappyMoonFace(ctx, cx, cy, r, moonFaceTimer);
    }

    moonFaceTimer--;
    if (moonFaceTimer <= 0) moonFace = null;
  }

  ctx.restore();
}

// ‚îÄ‚îÄ‚îÄ APPLY PHASE MASK TO COSMIC MOON ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function applyPhaseMaskToCosmicMoon(ctx) {
  ctx.save();
  ctx.globalCompositeOperation = "destination-out";

  // Draw the phase mask using the same logic as the old buffer system
  MOON_PIXELS.forEach((row, y) => {
    const { left, right } = getMoonRowBounds(row);
    if (left === -1) return;

    const width = right - left + 1;
    const maskLeft = moonX - 8 + left;
    const maskTop = moonY - 8 + y;

    switch (moonPhase) {
      case MOON_PHASES.NEW:
        ctx.fillRect(maskLeft, maskTop, width, 1);
        break;

      case MOON_PHASES.WAXING_CRESCENT:
        ctx.fillRect(maskLeft, maskTop, Math.floor(width * 0.65), 1);
        break;

      case MOON_PHASES.FIRST_QUARTER:
        ctx.fillRect(maskLeft, maskTop, Math.floor(width * 0.5), 1);
        break;

      case MOON_PHASES.WAXING_GIBBOUS:
        ctx.fillRect(maskLeft, maskTop, Math.floor(width * 0.25), 1);
        break;

      case MOON_PHASES.FULL:
        // no mask ‚Äî intentionally empty
        break;

      case MOON_PHASES.WANING_GIBBOUS:
        ctx.fillRect(maskLeft + Math.floor(width * 0.75), maskTop, Math.ceil(width * 0.25), 1);
        break;

      case MOON_PHASES.LAST_QUARTER:
        ctx.fillRect(maskLeft + Math.floor(width * 0.5), maskTop, Math.ceil(width * 0.5), 1);
        break;

      case MOON_PHASES.WANING_CRESCENT:
        ctx.fillRect(maskLeft + Math.floor(width * 0.35), maskTop, Math.ceil(width * 0.65), 1);
        break;
    }
  });

  ctx.restore();
}

// ‚îÄ‚îÄ‚îÄ DRAW WHISTLE FACES ON COSMIC MOON ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function drawWhistleFacesOnCosmicMoon(ctx) {
  // Old face drawing removed - now using new centered face system
}

// ‚îÄ‚îÄ‚îÄ MOON REFLECTION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function drawMoonReflection(ctx, moonX, moonY) {
  if (!moonVisible) return;

  const width = PHASE_REFLECTION_WIDTH[moonPhase];
  if (width === 0) return; // new moon = no reflection

  const centerX = moonX + 8; // center of 17√ó17 moon
  const height = 24;

  for (let y = 0; y < height; y++) {
    const alpha = 0.06 * (1 - y / height);
    const wobble = Math.sin(frameCount * 0.03 + y * 0.5) * 1.5;

    ctx.fillStyle = `rgba(235,232,225,${alpha})`;
    ctx.fillRect(centerX - width/2 + wobble, WATER_LINE_Y + y, width, 1);
  }
}

// ‚îÄ‚îÄ‚îÄ STARS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function drawStars(){
  stars.forEach(s=>{
    s.a=Math.min(s.a+0.003,1);
    ctx.globalAlpha=s.a;
    drawDot(s.x, s.y, s.c);
    ctx.globalAlpha=1;
  });
}

// ‚îÄ‚îÄ‚îÄ RAIN ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Initialize rain drops with unified system
const rainDropCount = 200;
const rainRandomValues = Array.from({length: rainDropCount}, () => ({
  x: detRandom() * W,
  y: detRandom() * H,
  l: 2 + Math.floor(detRandom() * 2),
  speed: 0.5 + detRandom() * 0.3
}));

for(let i = 0; i < rainDropCount; i++){
  const rand = rainRandomValues[i];
  rainDrops.push({x: rand.x, y: rand.y, l: rand.l, speed: rand.speed});
}

// ‚îÄ‚îÄ‚îÄ PUDDLES ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const puddlePixels = [];
const puddlePixelCount = 220;
const puddleRandomValues = Array.from({length: puddlePixelCount}, () => ({
  x: detRandom() * W,
  y: 138 + detRandom() * 25,
  alpha: 0.03 + detRandom() * 0.06,
  flicker: detRandom() * 2,
  drift: detRandom() * 0.3
}));

for(let i = 0; i < puddlePixelCount; i++){
  const rand = puddleRandomValues[i];
  puddlePixels.push({x: rand.x, y: rand.y, alpha: rand.alpha, flicker: rand.flicker, drift: rand.drift});
}

// ‚îÄ‚îÄ‚îÄ SPLASHES ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const splashes = [];

function createSplash(x, y){
  splashes.push({
    x: x,
    y: y,
    lifetime: 8,
    alpha: 1
  });
}

// ‚îÄ‚îÄ‚îÄ SIDEWALK SPLASHES ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const sidewalkSplashes = [];
function updateSidewalkSplashes(){
  rainDrops.forEach(drop=>{
    if(drop.y >=125 && drop.y <=135 && detRandom()<0.02){
      sidewalkSplashes.push({x:drop.x, y:130, lifetime:20+Math.floor(detRandom()*10)});
    }
  });
  sidewalkSplashes.forEach(s => s.lifetime--);
  for(let i=sidewalkSplashes.length-1;i>=0;i--){
    if(sidewalkSplashes[i].lifetime<=0) sidewalkSplashes.splice(i,1);
  }
}

// ‚îÄ‚îÄ‚îÄ MAIN LOOP & UPDATE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function update(dt = 1/60) {
  frameCount++;
  
  // Update smooth moon blend for atmospheric transitions (frame-rate independent)
  moonBlend = Math.min(1, moonBlend + 0.01 * dt * 60);
  
  // Always update hint screen if active
  hintScreen.update();
  
  updateEvents(playerX);

  moving = keys["ArrowRight"] || keys["ArrowLeft"] || keys["d"] || keys["D"] || keys["a"] || keys["A"];
  
  // DEBUG: Track player position relative to dock (DISABLED - issue resolved)
  // if (moving && DEBUG) {
  //   console.log('üîç Player Position:', playerX.toFixed(1), '| Dock Start:', DOCK_CONFIG.startX, '| Distance to Dock:', (DOCK_CONFIG.startX - playerX).toFixed(1));
  // }
  
  // Track player direction for whistle mouth position
  if(keys["ArrowRight"] || keys["d"] || keys["D"]) {
    playerX += walkSpeed * speedMultiplier;
    
    // ‚Üê CLAMP TO DOCK END (stop at water)
    if (maxPlayerX > 0 && playerX > maxPlayerX) {
      playerX = maxPlayerX;
    }
    
    facingRight = true;
    idleFrames = 0; // Reset idle when moving
  }
  if(keys["ArrowLeft"] || keys["a"] || keys["A"]) {
    playerX -= walkSpeed * speedMultiplier;
    facingRight = false;
    idleFrames = 0; // Reset idle when moving
  }
  
  // NEW: Idle tracking for moths
  if (!(keys["ArrowRight"] || keys["d"] || keys["D"] || keys["ArrowLeft"] || keys["a"] || keys["A"])) {
    idleFrames++;
  } else {
    idleFrames = 0;
  }
  
  // Window Ghost Wave: still under right-side building (account for parallax)
  const ghostBuilding = buildings[0]; // First right-side building
  const buildingScreenX = ~~(ghostBuilding.x - playerX * 0.4); // Building position on screen
  const underGhostBuilding = buildingScreenX > -10 && buildingScreenX < 40; // Very tight 50px trigger range
  
  if (!moving && underGhostBuilding) {
    stillUnderGhost++;
  } else {
    stillUnderGhost = 0;
  }
  if (stillUnderGhost > 300 && !ghostActive) {
    ghostActive = true;
    ghostTimer = 1200; // 20s duration
  }
  if (ghostActive) {
    ghostTimer--;
    ghostWave += 0.12;
    ghostMorse += 0.15;
    if (ghostTimer <= 0) {
      ghostActive = false;
    }
  }
  
  // ‚ú® NEW: Puddle Reverie - standing still over your reflection
  if (!moving && !puddleReverieActive) {
    // Check if player is standing over a puddle with their reflection
    const playerScreenX = 60;
    const playerScreenY = player.y;
    let overReflection = false;
    
    for (const puddle of puddles) {
      const puddleScreenX = ~~(puddle.x - playerX * 0.7);
      const puddleScreenY = ~~puddle.y;
      const puddleCenterScreenX = puddleScreenX + puddle.w / 2;
      const threshold = puddle.w / 2 + 30;
      
      // Check if player is near this puddle
      if (Math.abs(puddleCenterScreenX - playerScreenX) < threshold) {
        const dy = puddle.y - player.y;
        const dist = Math.abs(dy);
        if (dist < 80 && dy > 0) { // puddle is below player
          overReflection = true;
          break;
        }
      }
    }
    
    if (overReflection) {
      stillOverPuddle++;
    } else {
      stillOverPuddle = 0;
    }
    
    // Trigger after 10 seconds (600 frames at 60fps)
    if (stillOverPuddle > 600) {
      puddleReverieActive = true;
      puddleReverieTimer = 420; // 7 seconds total animation
      puddleReverieWavePhase = 0;
      // if (DEBUG) console.log("üíß Puddle Reverie: Your reflection acknowledges you...");
    }
  } else if (moving) {
    stillOverPuddle = 0;
  }

  // Update puddle reverie animation
  if (puddleReverieActive) {
    puddleReverieTimer--;
    puddleReverieWavePhase += 0.08;
    
    if (puddleReverieTimer <= 0) {
      puddleReverieActive = false;
    }
  }
  
  // Update whistle duration
  if (whistleDuration > 0) {
    whistleDuration--;
    if (whistleDuration === 0) {
      whistling = false;
    }
  }

  // Phase mood tint on whistle + moon visible (skip full moon, waxing crescent, first quarter)
  if (whistling && whistleDuration === WHISTLE_DURATION - 1 
      && moonVisible 
      && moonPhase !== MOON_PHASES.FULL 
      && moonPhase !== MOON_PHASES.WAXING_CRESCENT   // ‚Üê skip orange
      && moonPhase !== MOON_PHASES.FIRST_QUARTER     // ‚Üê skip yellow
      && !moodTintActive) {
    
    if (DEBUG) console.log(`Debug: Whistle trigger conditions met - moonVisible=${moonVisible}, moonPhase=${moonPhase}, moodTintActive=${moodTintActive}`);
    
    if (Math.random() < 0.6) {  // 60% chance ‚Äî frequent enough to notice occasionally
      moodTintActive = true;
      moodTintTimer = 600 + Math.random() * 300;  // 10‚Äì15 seconds
      
      // Select vibrant fluorescent tint based on phase (subtle version)
      let h, s, l, aMax;
      switch (moonPhase) {
        case MOON_PHASES.NEW:
          h = 0; s = 0; l = 0; aMax = 0; break;   // Removed tint for new moon (keep evil wink face only)
        case MOON_PHASES.WAXING_CRESCENT:
          h = 30;  s = 98; l = 60; aMax = 0.06; break;    // Fluorescent Orange (much more subtle)
        case MOON_PHASES.FIRST_QUARTER:
          h = 60;  s = 96; l = 65; aMax = 0.06; break;    // Fluorescent Yellow (much more subtle)
        case MOON_PHASES.WAXING_GIBBOUS:
          h = 120; s = 94; l = 58; aMax = 0.07; break;    // Fluorescent Green (much more subtle)
        case MOON_PHASES.WANING_GIBBOUS:
          h = 240; s = 92; l = 62; aMax = 0.07; break;    // Fluorescent Blue (much more subtle)
        case MOON_PHASES.LAST_QUARTER:
          h = 280; s = 97; l = 60; aMax = 0.06; break;    // Fluorescent Violet (much more subtle)
        case MOON_PHASES.WANING_CRESCENT:
          h = 330; s = 95; l = 64; aMax = 0.07; break;    // Fluorescent Pink/Magenta (much more subtle)
        default:
          h = 0; s = 0; l = 0; aMax = 0;
      }
      
      moodTintColor = { h, s, l, a: aMax };
      moodVignetteStrength = 0.04 + Math.random() * 0.03;  // much lighter edge darkening (4-7%)
      
      if (DEBUG) console.log(`Fluorescent mood tint activated ‚Äî phase ${moonPhase}, hue ${h}, alpha ${aMax}, vignette ${moodVignetteStrength.toFixed(3)}`);
    } else {
      if (DEBUG) console.log(`Debug: Random check failed (${Math.random()} >= 0.6)`);
    }
  } else if (whistling && whistleDuration === WHISTLE_DURATION - 1) {
    if (DEBUG) console.log(`Debug: Whistle trigger failed - moonVisible=${moonVisible}, moonPhase=${moonPhase}, moodTintActive=${moodTintActive}`);
  }

  if (moodTintActive) {
    moodTintTimer--;
    if (moodTintTimer <= 0) {
      moodTintActive = false;
      moodVignetteStrength = 0;
    }
  }

  // New moon evil wink on whistle
  if (whistling && whistleDuration === WHISTLE_DURATION - 1 
      && moonVisible 
      && moonPhase === MOON_PHASES.NEW 
      && !newMoonEvilWinkActive) {
    
    if (Math.random() < 0.5) {
      newMoonEvilWinkActive = true;
      newMoonEvilWinkTimer = 360;   // ~6 seconds ‚Äî longer & more menacing
      newMoonEvilWinkFrame = 0;
      moonFace = 'angry';
      moonFaceTimer = MOON_FACE_DURATION;
      if (DEBUG) console.log("üåë New moon gave an evil wink...");
    }
  }

  if (newMoonEvilWinkActive) {
    newMoonEvilWinkTimer--;
    
    // Slower, more deliberate animation: glare ‚Üí slow evil wink ‚Üí hold ‚Üí fade
    if (newMoonEvilWinkTimer > 240) {
      newMoonEvilWinkFrame = 0;  // intense stare
    } else if (newMoonEvilWinkTimer > 120) {
      newMoonEvilWinkFrame = 1;  // slow evil wink (right eye becomes vertical slit)
    } else {
      newMoonEvilWinkFrame = 2;  // hold narrowed eye, then fade
    }
    
    if (newMoonEvilWinkTimer <= 0) {
      newMoonEvilWinkActive = false;
      newMoonEvilWinkFrame = 0;
    }
  }

  // Full moon crater smile + wink on whistle
  if (whistling && whistleDuration === WHISTLE_DURATION - 1 
      && moonVisible 
      && moonPhase === MOON_PHASES.FULL 
      && !fullMoonSmileActive) {
    
    if (Math.random() < 0.45) {  // ~45% chance ‚Äî rare enough to feel special
      fullMoonSmileActive = true;
      fullMoonSmileTimer = 180;   // ~3 seconds @60fps
      fullMoonSmileFrame = 1;     // start with smile
      moonFace = 'happy';
      moonFaceTimer = MOON_FACE_DURATION;
      if (DEBUG) console.log("üåï Full moon crater smiled!");
    }
  }

  if (fullMoonSmileActive) {
    fullMoonSmileTimer--;
    
    // Sequence: smile appears ‚Üí hold ‚Üí double blink ‚Üí hold ‚Üí fade
    if (fullMoonSmileTimer > 140) {
      fullMoonSmileFrame = 1;  // wide grin visible, eyes open
    } else if (fullMoonSmileTimer > 100) {
      fullMoonSmileFrame = 2;  // first blink (eyes closed)
    } else if (fullMoonSmileTimer > 90) {
      fullMoonSmileFrame = 1;  // quick open
    } else if (fullMoonSmileTimer > 50) {
      fullMoonSmileFrame = 3;  // second blink (eyes closed again)
    } else {
      fullMoonSmileFrame = 1;  // final open + fade
    }
    
    if (fullMoonSmileTimer <= 0) {
      fullMoonSmileActive = false;
      fullMoonSmileFrame = 0;
    }
  }

  if(moving) {
    const stepSpeed = 6 + Math.floor(twilight*4);
    stepTimer++;
    if(stepTimer > stepSpeed) { 
      stepFrame = 1 - stepFrame;
      stepTimer = 0;
    }
    updateFootsteps(); // Distance-based footstep system
  } else {
    stepFrame = 0;
    stepTimer = 0;
  }

  const rate = moving ? 0.0002 : 0.0005;
  if(playerX >= levelEndX - 100) {
    twilight += rate*(0.6 + twilight*0.8);
    twilight = Math.min(twilight, 1);
    if(twilight >= 1) {
      gameEnded = true;
    }
  }

  if (lampAlpha < 1) {
    lampAlpha += lampFadeSpeed;
    if (lampAlpha > 1) lampAlpha = 1;
  }

  // ü¶ã Update moths (time-based discovery system)
  updateMoths();

  if(twilight > 0.4 && detRandom() < 0.025){
    const colors = [C.starA, C.starB];
    stars.push({x: detRandom()*W, y: detRandom()*70, a: 0, c: colors[Math.floor(detRandom()*colors.length)]});
  }

  updateNightEffects();
  updateDock(dt);
  updateSeagulls(1); // Update seagulls with delta time
  updateCloudSpawning(playerX); // Spawn new clouds as player walks
  updateClouds(1); // Update clouds with delta time

  // Always update fireflies - they should move throughout the game
  updateFireflies();
  
  // Update moths (time-based discovery system)
  updateMoths();
  
  // Check moth discovery conditions
  checkMothDiscovery();
  
  // Update cinematic player shooting stars
  updatePlayerShootingStars();
  
  if(!moving && twilight < OPTIMIZATION.heavyUpdateThreshold) {
    updateWindows();
    updatePuddles();
  } else {
    updateShootingStars();
    updateWindows();
  }

  // Cloud updates are handled by updateClouds() function above

  // üåßÔ∏è Smooth rain intensity (EVERY FRAME) - faster smoothing
  rainIntensity += (rainTarget - rainIntensity) * 0.08;

  // Update rain audio system
  updateRainAudio(rainIntensity, dt);

  // üåßÔ∏è Continuous rain spawning (NOT event-based)
  const spawnRate = Math.floor(rainIntensity * 6);
  if (spawnRate > 0) {
    // Pre-calculate shared values
    const baseSpeed = 2 + rainIntensity * 4;
    const baseAlpha = 0.3 + rainIntensity * 0.4;
    
    for (let i = 0; i < spawnRate; i++) {
      rainDrops.push({
        x: detRandom() * W,
        y: -5,
        speed: baseSpeed + detRandom() * 1.5,
        alpha: baseAlpha
      });
    }
  }

  // üåßÔ∏è Rain physics (always running)
  for (let i = rainDrops.length - 1; i >= 0; i--) {
    const r = rainDrops[i];
    r.y += r.speed;

    if (r.y > H) rainDrops.splice(i, 1);
  }

  windows.forEach(w => {
    w.timer += 1;
    w.alpha = (0.55 + Math.sin(w.timer*0.05)*0.25) * NIGHT_EFFECTS.windowGlowMultiplier;
  });

  updateSplashes();
  updateSidewalkSplashes();
  updatePuddles();

  const playerRainSplashChance = 0.05;
  if(rainDrops.some(r => Math.abs(r.x - (playerX + 60)) < 3 && r.y > 120 && detRandom() < playerRainSplashChance)) {
    sidewalkSplashes.push({ x: 60 + detRandom()*4, y: 125, lifetime: 10 + Math.floor(detRandom()*5) });
  }

  fieldLine.blades.forEach(blade => blade.offset = Math.sin(Date.now()*0.001 + blade.sway) * 1);

  if(ufo.active){
    ufo.y += ufo.vy;
    ufo.alpha = Math.min(ufo.alpha + 0.02, 1);
    
    // Start UFO hum when it becomes active
    if (!ufo.humStopper) {
      ufo.humStopper = playUfoHum(true);
    }
    
    if(ufo.y < -10) {
      ufo.active = false;
      // Stop UFO hum when it disappears
      if (ufo.humStopper) {
        ufo.humStopper();
        ufo.humStopper = null;
      }
    }
  } else {
    // Clean up any lingering hum if UFO is inactive
    if (ufo.humStopper) {
      ufo.humStopper();
      ufo.humStopper = null;
    }
  }

  // Update cat event
  updateCat();
  
  // Update pawprints
  updatePawprints();
  
  // Update goose event
  updateGeese(playerX, dt);
  
  // Update UFO sparkles
  updateUfoSparkles();
  
  // Update lamp sparkles
  updateLampParticles(0.3 + twilight * 0.7); // 30% to 100% brightness as night progresses
  
  // Update moon-based player reflection
  const moonActive = moonVisible && moonPhase !== MOON_PHASES.NEW;
  if (moonActive) {
    moonReflectionAlpha = Math.min(1, moonReflectionAlpha + 0.01);
  } else {
    moonReflectionAlpha = Math.max(0, moonReflectionAlpha - 0.01);
  }
  
  // Update dock lamp sparkles
  updateDockLampSparkles();
  
  // Update moths (time-based discovery system)
  updateMoths();
  
  // Check moth discovery conditions
  checkMothDiscovery();
}

// ‚îÄ‚îÄ‚îÄ UPDATE GEESE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function updateGeese(playerX, dt = 1/60) {
    geese.forEach((goose, index) => {
        if (goose.state === "idle") {
            // Frame-rate independent idle bob animation
            goose.bob = Math.sin(Date.now() * 0.002 + goose.phase) * 1;

            // Trigger takeoff when player approaches
            if (playerX > goose.x - 60) {
                goose.state = "takingOff";
                goose.timer = 0;

                // Distance-based volume + pitch variation
                const v = distanceVolume(goose.x, playerX, 320);
                playGooseHonk(v, goose.pitchVar);
            }
        }

        if (goose.state === "takingOff") {
            goose.timer++;
            goose.y -= 1.5; // Fly upward
            goose.x += Math.cos(goose.angle) * 1.2; // Fly at angle

            if (goose.timer > 60) goose.state = "gone";
        }
    });
}

// ‚îÄ‚îÄ‚îÄ UPDATE CAT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function updateCat() {
    // Trigger cat event
    if (!cat.triggered && playerX >= catTriggerX) {
        cat.active = true;
        cat.x = playerX - 150;
        cat.triggered = true;
        if (DEBUG) console.log('Cat triggered - playing meow sound');
        playCatMeow(); // Original meow
    }

    if (cat.active) {
        // Optional: cat slows slightly when close and ahead, before possible interaction
        if (cat.x > playerX && cat.x < playerX + 120 && !cat.interacting) {
            cat.speed = Math.max(0.6, cat.speed - 0.04); // gentle brake
        } else if (!cat.interacting) {
            cat.speed = 1.5; // full speed otherwise
        }

        // Whistle interaction: only when cat is already PAST the player (in front)
        if (!cat.interacting 
            && whistling 
            && cat.x > playerX                          // ENSURED: cat MUST be ahead/to the right
            && cat.x < playerX + 150                    // ‚Üê INCREASED: Larger trigger window (was 80)
            && detRandom() < 0.5) {                     // ‚Üê LOWERED: Higher reaction chance (was 0.6)
            
            if (DEBUG) console.log('Cat interaction conditions met!', {
                catX: cat.x,
                playerX: playerX,
                distance: cat.x - playerX,               // Positive distance since cat > playerX
                whistling: whistling,
                random: detRandom()
            });
            
            cat.interacting = true;
            cat.interactTimer = 90; // 1.5s total
            cat.speed = 0;
            cat.skidTimer = 18;     // brief skid left
            playCatMeow(1.15, 1);   // higher-pitched reply (single burst, no beep)
            
            // Spawn 5 pawprints (skid trail behind cat)
            for (let i = 0; i < 5; i++) {
                const ox = -10 + detRandom() * 15;
                const oy = 2 + detRandom() * 4;
                pawprints.push({
                    x: cat.x + ox,
                    y: cat.y + oy,
                    age: 0,
                    maxAge: 180 // 3 seconds at 60fps
                });
            }
            if (DEBUG) console.log('Cat looked back curiously! (ahead of player)');
        }

        // Handle interaction
        if (cat.interacting) {
            cat.interactTimer--;
            if (cat.skidTimer > 0) {
                cat.skidTimer--;
                cat.x -= 0.8; // Slide-stop left
            }
            if (cat.interactTimer <= 0) {
                cat.interacting = false;
                cat.speed = 1.5; // Resume
            }
        }

        // Move
        cat.x += cat.speed;

        // Animate
        cat.frame += cat.frameSpeed;
        if (cat.frame > 3) cat.frame = 0;

        // Deactivate far past player
        if (cat.x > playerX + 500) cat.active = false;
    }
}

// ‚îÄ‚îÄ‚îÄ UPDATE SPLASHES ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function updateSplashes() {
  const dropSpeed = 4 + rainIntensity * 1.5;
  const splashChance = 0.06 + 0.08 * rainIntensity;

  rainDrops.forEach(drop => {
    drop.y += dropSpeed;  // Fall continuous!

    if (drop.y >= 125 && drop.y <= 135 && detRandom() < splashChance) {
      splashes.push({ x: drop.x, y: 130, lifetime: 15 + Math.floor(detRandom() * 10) });
    } else if (drop.y >= 130 && drop.y <= H && detRandom() < splashChance) {
      splashes.push({ x: drop.x, y: 130 + Math.floor(detRandom() * 20), lifetime: 12 + Math.floor(detRandom() * 8) });
    }

    if (drop.y >= H) {
      drop.y = -detRandom() * 100;  // LOOP: Continuous rain
      drop.x = detRandom() * W;
    }
  });

  splashes.forEach(s => s.lifetime--);
  for (let i = splashes.length - 1; i >= 0; i--) {
    if (splashes[i].lifetime <= 0) splashes.splice(i, 1);
  }
}

// ‚îÄ‚îÄ‚îÄ PAWPRINT SYSTEM ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function createPawprint(x, y) {
  pawprints.push({
    x: x,
    y: y,
    age: 0,
    maxAge: 180, // 3 seconds at 60fps
    alpha: 1.0
  });
}

function updatePawprints() {
  for (let i = pawprints.length - 1; i >= 0; i--) {
    const p = pawprints[i];
    p.age++;
    
    // Fade out over lifetime
    p.alpha = Math.max(0, 1 - (p.age / p.maxAge));
    
    // Apply twilight dimming
    p.alpha *= (0.4 + twilight * 0.6);
    
    // Remove old pawprints
    if (p.age >= p.maxAge) {
      pawprints.splice(i, 1);
    }
  }
}

function drawPawprints() {
  pawprints.forEach(p => {
    const screenX = p.x - playerX; // Player-layer parallax
    
    // Age-based fade: more transparent as they age
    const fade = 1 - (p.age / p.maxAge);
    const alpha = fade * 0.12;           // much more subtle opacity (reduced from 0.35)
    
    // Base print: cool twilight blue-gray
    ctx.fillStyle = `rgba(160, 180, 220, ${alpha})`;  // soft blue-gray
    ctx.beginPath();
    ctx.ellipse(screenX, p.y, 3.5, 2.2, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // White/silver highlight on top-left ‚Üí gives "frosty" moonlit look
    ctx.fillStyle = `rgba(235, 240, 255, ${alpha * 0.7})`;  // pale blue-white
    ctx.beginPath();
    ctx.ellipse(screenX - 1.2, p.y - 0.6, 1.4, 0.9, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Very faint violet rim (optional twilight accent)
    ctx.fillStyle = `rgba(190, 180, 240, ${alpha * 0.25})`;
    ctx.beginPath();
    ctx.ellipse(screenX + 0.8, p.y + 0.4, 2.8, 1.8, 0, 0, Math.PI * 2);
    ctx.fill();
  });
}

// ‚îÄ‚îÄ‚îÄ UPDATE WINDOWS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function updateWindows(){
  windows.forEach(w => {
    w.timer += 1;
    w.alpha = (0.55 + Math.sin(w.timer*0.05)*0.25) * NIGHT_EFFECTS.windowGlowMultiplier;
  });
}

// ‚îÄ‚îÄ‚îÄ UPDATE PUDDLES ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function updatePuddles(){
  puddlePixels.forEach(p => {
    p.flicker += 0.01;
    p.alpha += Math.sin(p.flicker) * 0.001;

    p.x -= (playerX * 0.0003);

    if(detRandom() < 0.002){
      p.alpha = Math.min(p.alpha + 0.05, 0.09); // ‚Üê LOWERED max: was 0.12 ‚Üí 0.09 (35% more transparent!)
    }
  });
}

// ‚îÄ‚îÄ‚îÄ DRAW ALL BUILDINGS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function drawBuildings() {
  // Original building
  buildings.forEach((b, i) => {
    ctx.fillStyle = C.building;
    ctx.fillRect(b.x - playerX*0.4, b.y, b.width, b.height);

    windowsPerBuilding.forEach((w, windowIndex) => {
      let hue = 42 + w.hueOffset;
      let flickerMult = 1; // Morse pulse multiplier

      // Ghost effect: specific window of first right-side building (i=0, xOffset=30/yOffset=35)
      if (i === 0 && w.xOffset === 30 && w.yOffset === 35 && ghostActive) {
        hue = 170 + 20 * Math.sin(ghostWave); // Cyan pulse (170-190)
        flickerMult = 0.8 + 0.4 * Math.sin(ghostMorse * 2.5); // Morse-like rhythm (dot/dash feel)
      }

      const alpha = (0.55 + Math.sin(w.timer * w.speed * flickerMult) * (ghostActive ? 0.35 : 0.25)) * 
                    NIGHT_EFFECTS.windowGlowMultiplier * (0.8 + twilight*0.4);
      ctx.fillStyle = `hsla(${hue}, 80%, 65%, ${alpha})`;
      ctx.fillRect(b.x + w.xOffset - playerX*0.4, b.y + w.yOffset, w.size, w.size);

      // Ghost creature: small silhouette with glowing eyes that slowly rises to look
      if (i === 0 && w.xOffset === 30 && w.yOffset === 35 && ghostActive) {
        const winScreenX = ~~(b.x + w.xOffset - playerX*0.4);
        const winScreenY = ~~(b.y + w.yOffset);

        // Clip to window bounds to prevent ghost from showing outside
        ctx.save();
        ctx.beginPath();
        ctx.rect(winScreenX, winScreenY, w.size, w.size);
        ctx.clip();

        // Base alpha ‚Äî very faint, dims more at high twilight
        const baseAlpha = (0.38 + 0.18 * Math.sin(ghostWave * 0.7)) * (1 - twilight * 0.12);

        // Rise from bottom of window (starts lower, slowly comes up)
        const riseProgress = Math.min(1, ghostTimer / 600); // takes ~10 seconds to fully rise
        const riseOffset = (1 - riseProgress) * 6;           // starts 6px lower

        // Creature body ‚Äî small hunched silhouette (dark gray-blue)
        ctx.fillStyle = `rgba(40, 50, 70, ${baseAlpha * 0.9})`;
        ctx.fillRect(winScreenX + 0.5, winScreenY + 7 + riseOffset, 5, 5);     // main body (moved down 5px total)
        ctx.fillRect(winScreenX + 1.5, winScreenY + 5 + riseOffset, 3, 2);     // head-ish (moved down 5px total)

        // Two glowing eyes ‚Äî tiny, pulsing slowly
        const eyePulse = 0.6 + 0.4 * Math.sin(ghostWave * 1.1 + 0.8);
        ctx.fillStyle = `rgba(180, 240, 255, ${baseAlpha * eyePulse})`; // cyan glow
        ctx.fillRect(winScreenX + 1.2, winScreenY + 8.2 + riseOffset, 1, 1);   // left eye (moved down 5px total)
        ctx.fillRect(winScreenX + 3.8, winScreenY + 8.2 + riseOffset, 1, 1);   // right eye (moved down 5px total)

        // Very faint eye highlight (makes them pop just a tiny bit)
        ctx.fillStyle = `rgba(255, 255, 255, ${baseAlpha * eyePulse * 0.4})`;
        ctx.fillRect(winScreenX + 1.4, winScreenY + 8.4 + riseOffset, 0.6, 0.6); // moved down 5px total
        ctx.fillRect(winScreenX + 4.0, winScreenY + 8.4 + riseOffset, 0.6, 0.6); // moved down 5px total

        ctx.restore(); // Remove clipping
      }

      // increment timer to keep original windows flickering
      w.timer += 1;
    });
  });

  // Left buildings with independent flicker rates
  leftBuildings.forEach((b, i) => {
    ctx.fillStyle = C.building;
    ctx.fillRect(b.x - playerX*0.4, b.y, b.width, b.height);

    leftBuildingWindows[i].forEach(w => {
      const hue = 42 + w.hueOffset;
      const alpha = (0.55 + Math.sin(w.timer * w.speed) * 0.25) * NIGHT_EFFECTS.windowGlowMultiplier * (0.8 + twilight*0.4);
      ctx.fillStyle = `hsla(${hue}, 80%, 65%, ${alpha})`;
      ctx.fillRect(b.x + w.xOffset - playerX*0.4, b.y + w.yOffset, w.size, w.size);

      // increment timer for continuous flicker
      w.timer += 1;
    });
  });
}

// ‚îÄ‚îÄ‚îÄ DRAW FENCE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function drawFence(){
  ctx.fillStyle = C.fence;
  const time = Date.now() * 0.001;
  for(let i=0;i<fenceOffsets.length;i++){
    const postX=~~(i*12 - 320 - playerX*0.8); // Shift 320px left (extended by 80px)
    const postY=~~(120 + Math.sin((fenceOffsets[i] + time) * 2)*1.5);
    ctx.fillRect(postX,postY,2,20);
  }
}

// ‚îÄ‚îÄ‚îÄ DRAW FENCE BARS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function drawFenceBars(){
  ctx.strokeStyle = C.fence;
  ctx.lineWidth = 1;

  const barOffsets = [5, 15];
  const time = Date.now() * 0.001;

  for(const offset of barOffsets){
    ctx.beginPath();
    for(let i = 0; i < fenceOffsets.length; i++){
      const postX = i*12 - 320 - playerX*0.8; // Shift 320px left (extended by 80px)
      const postY = 120 + Math.sin((fenceOffsets[i] + time) * 2)*1.5 + offset;
      if(i === 0){
        ctx.moveTo(postX, postY);
      } else {
        ctx.lineTo(postX, postY);
      }
    }
    ctx.stroke();
  }
}


// ‚îÄ‚îÄ‚îÄ DRAW CLOUDS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function hash2(x, y) {
  return (
    Math.sin(x * 127.1 + y * 311.7) * 43758.5453
  ) % 1;
}


// ‚îÄ‚îÄ‚îÄ UPDATE FIELD LINE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function updateFieldLine(){
  fieldLine.blades.forEach(blade => {
    blade.offset = Math.sin(Date.now()*0.001 + blade.sway) * 1;
  });
}

// ‚îÄ‚îÄ‚îÄ DRAW PUDDLES ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function drawPuddles(){
  // Subtle glass puddles (base + sheen)
  puddles.forEach((p, i) => {
    const screenX = ~~(p.x - playerX * 0.7);  // Road parallax
    const screenY = ~~p.y;

    // Base: translucent road-blue (blends invisibly) - improved readability
    ctx.globalAlpha = Math.max(
      0.45,
      p.baseAlpha * (0.75 + twilight * 0.35)
    );
    ctx.fillStyle = `rgba(38, 48, 68, 1)`;  // Matches water/road darks
    ctx.fillRect(screenX, screenY, p.w, p.h);

    // Sheen: soft light catch (sin-shimmer for glass ripple) - much more transparent
    const time = frameCount * 0.02 + p.x * 0.01;
    const shimmer = 0.3 + 0.4 * Math.sin(time);
    const sheenAlpha = Math.max(0.15, p.baseAlpha * 0.4 * (0.5 + twilight * 0.5) * shimmer);  // Much more transparent
    ctx.fillStyle = `rgba(185, 195, 225, ${sheenAlpha})`;  // Pale sky-blue
    // Inner water surface ‚Äî much larger, thinner borders
    ctx.fillRect(
      screenX + p.w * 0.02,   // very thin border (was 0.06)
      screenY + p.h * 0.08,   // very thin border (was 0.12)
      p.w * 0.96,             // covers almost all of puddle (was 0.88)
      p.h * 0.84              // covers most of puddle (was 0.55)
    );
    
    // Optional extra softness
    ctx.globalAlpha *= 0.9;

    ctx.globalAlpha = 1;
  });
}

// Player/Cat Reflections in puddles
// 
// GOAL: Reflections appear naturally when player/cat walk by puddles
// KEY CHANGE: Switched from strict world-space bounding box to forgiving screen-space distance
function drawPuddleReflections() {
  if (puddles.length === 0) return;
  
  // 1. Parallax offset used for most background elements (including puddles)
  const camX = playerX * 0.7;

  // 2. Player is always drawn at fixed screen position (no parallax for player layer)
  const playerScreenX = 60;
  const playerScreenY = player.y;   // usually ~120

  // 3. Cat uses world ‚Üí screen conversion (assuming cat moves in world space like most objects)
  const catScreenX = ~~(cat.x - playerX);
  const catScreenY = ~~cat.y;

  for (const puddle of puddles) {
    // 4. Convert puddle world position ‚Üí screen position (same parallax as ground)
    const puddleScreenX = ~~(puddle.x - playerX * 0.7);
    const puddleScreenY = ~~puddle.y;
    
    // Quick culling: skip puddles completely off-screen
    if (puddleScreenX + puddle.w < 0 || puddleScreenX > W) continue;

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // NEW TRIGGER LOGIC ‚Äì THIS IS THE BIG CHANGE
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    // Use center of puddle on screen as reference point
    const puddleCenterScreenX = puddleScreenX + puddle.w / 2;

    // Trigger radius = half puddle width + extra margin (30px)
    //    ‚Üí bigger puddles affect player from farther away
    const threshold = puddle.w / 2 + 30;

    // Simple horizontal distance check in screen space
    //    ‚Üí feels like "walking by" or "standing near"
    const playerInZone = Math.abs(puddleCenterScreenX - playerScreenX) < threshold;
    
    const catInZone = cat.active && 
                      Math.abs(puddleCenterScreenX - catScreenX) < threshold;

    // If neither player nor cat is close enough horizontally ‚Üí skip this puddle
    if (!playerInZone && !catInZone) continue;

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // Distance-based strength & stretch (unchanged from good parts of old version)
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    const dy = puddle.y - player.y;
    const dist = Math.abs(dy);
    const MAX_REFLECT_DIST = 80;

    let reflectStrength = 1 - dist / MAX_REFLECT_DIST;
    reflectStrength = Math.max(0, Math.min(1, reflectStrength));

    // Weaken reflections that are above player
    if (dy < 0) reflectStrength *= 0.35;

    const stretch = 1 + dist * 0.015;

    // Same logic for cat (in case cat.y is meaningfully different)
    const dy_cat = puddle.y - cat.y;
    const dist_cat = Math.abs(dy_cat);
    let reflectStrength_cat = 1 - dist_cat / MAX_REFLECT_DIST;
    reflectStrength_cat = Math.max(0, Math.min(1, reflectStrength_cat));
    if (dy_cat < 0) reflectStrength_cat *= 0.35;
    const stretch_cat = 1 + dist_cat * 0.015;

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // Render to temporary canvas, then composite with ripple
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    // Temp canvas is EXACTLY puddle size
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = Math.ceil(puddle.w);
    tempCanvas.height = Math.ceil(puddle.h);
    const tempCtx = tempCanvas.getContext('2d');

    // Player reflection
    if (playerInZone) {
      // Position on temp canvas = screen pos - puddle top-left
      const relPlayerX = playerScreenX - puddleScreenX;
      const relPlayerY = playerScreenY - puddleScreenY;

      tempCtx.save();
      tempCtx.translate(relPlayerX + 3, relPlayerY + 12); // player center

      const ripple = Math.sin(frameCount * 0.08 + puddle.seed) * dist * 0.01;
      tempCtx.translate(0, ripple);

      // ‚ú® NEW: Puddle Reverie - reflection waves independently
      if (puddleReverieActive && puddleReverieTimer > 180) {
        // Wave animation - reflection's arm moves
        const waveOffset = Math.sin(puddleReverieWavePhase) * 2;
        tempCtx.translate(waveOffset, 0);
      }

      tempCtx.scale(1, -stretch);           // vertical flip + stretch
      
      // ‚ú® NEW: Fade out reflection during particle phase
      let reflectionAlpha = 0.28 * reflectStrength;
      if (puddleReverieActive && puddleReverieTimer < 180) {
        reflectionAlpha *= (puddleReverieTimer / 180); // fade as particles appear
      }
      tempCtx.globalAlpha = reflectionAlpha;

      tempCtx.fillStyle = player.topColor;
      tempCtx.fillRect(-3, -12, 6, 12);     // simplified player body
      
      // ‚ú® NEW: Draw waving arm during reverie (phase 1: wave appears)
      if (puddleReverieActive && puddleReverieTimer > 240) {
        tempCtx.fillStyle = player.topColor;
        const armY = -8 + Math.sin(puddleReverieWavePhase) * 1.5;
        tempCtx.fillRect(3, armY, 2, 4); // waving arm
      }

      tempCtx.restore();
    }

    // Cat reflection (similar)
    if (catInZone) {
      const relCatX = catScreenX - puddleScreenX;
      const relCatY = catScreenY - puddleScreenY;

      tempCtx.save();
      tempCtx.translate(relCatX + 3, relCatY + 12);

      const ripple = Math.sin(frameCount * 0.08 + puddle.seed) * dist_cat * 0.01;
      tempCtx.translate(0, ripple);

      tempCtx.scale(catFacing, -stretch_cat);
      tempCtx.globalAlpha = 0.25 * reflectStrength_cat;

      tempCtx.fillStyle = '#FFD700';
      tempCtx.fillRect(-3, -8, 6, 8);
      tempCtx.fillRect(-2, -10, 1, 2);   // left ear
      tempCtx.fillRect(1, -10, 1, 2);    // right ear

      tempCtx.restore();
    }

    // Final composite with subtle vertical ripple
    const rippleOffset = Math.sin(waterRippleOffset * 2 + puddle.x * 0.1) * 0.5;

    ctx.save();
    ctx.globalAlpha = puddle.baseAlpha * 2.5;  // Increased visibility: was 2.0
    ctx.drawImage(tempCanvas, puddleScreenX, puddleScreenY + rippleOffset);

    // ‚ú® NEW: Blue flashy effects during puddle reverie
    if (puddleReverieActive && playerInZone) {
      const puddleCenterX = puddleScreenX + puddle.w / 2;
      const puddleCenterY = puddleScreenY + puddle.h / 2;
      
      // Clip effects to puddle shape
      ctx.save();
      ctx.beginPath();
      ctx.ellipse(puddleCenterX, puddleCenterY, puddle.w / 2, puddle.h / 2, 0, 0, Math.PI * 2);
      ctx.clip();
      
      // 1. Pulsing blue ripples (like ghost window effect)
      const pulsePhase = puddleReverieWavePhase * 0.5;
      const pulseIntensity = 0.3 + 0.4 * Math.sin(puddleReverieWavePhase * 1.2);
      
      // Cyan/blue hue that shifts (similar to ghost: 170-190)
      const blueHue = 190 + 15 * Math.sin(puddleReverieWavePhase * 0.8);
      
      // Draw expanding ripple rings
      for (let i = 0; i < 3; i++) {
        const rippleRadius = Math.max(1, (puddle.w / 2) * (0.3 + i * 0.3) + Math.sin(pulsePhase + i * 0.5) * 3);
        const rippleAlpha = pulseIntensity * (0.4 - i * 0.1) * (puddleReverieTimer / 420);
        
        ctx.strokeStyle = `hsla(${blueHue}, 80%, 65%, ${rippleAlpha})`;
        ctx.lineWidth = 1 + i * 0.5;
        ctx.beginPath();
        ctx.arc(puddleCenterX, puddleCenterY, rippleRadius, 0, Math.PI * 2);
        ctx.stroke();
      }
      
      // 2. Bright center glow (intense blue flash)
      if (puddleReverieTimer > 240) {
        const glowIntensity = 0.5 + 0.3 * Math.sin(puddleReverieWavePhase * 2);
        const glowGrad = ctx.createRadialGradient(
          puddleCenterX, puddleCenterY, 0,
          puddleCenterX, puddleCenterY, puddle.w * 0.6
        );
        glowGrad.addColorStop(0, `hsla(${blueHue}, 90%, 75%, ${glowIntensity * 0.6})`);
        glowGrad.addColorStop(0.5, `hsla(${blueHue}, 80%, 60%, ${glowIntensity * 0.3})`);
        glowGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
        
        ctx.fillStyle = glowGrad;
        ctx.fillRect(puddleScreenX, puddleScreenY, puddle.w, puddle.h);
      }
      
      // 3. Floating sparkle particles (rising through water)
      if (puddleReverieTimer < 300) {
        const sparkleCount = Math.floor(puddle.w / 8); // More sparkles in bigger puddles
        
        for (let s = 0; s < sparkleCount; s++) {
          // Each sparkle has its own phase offset
          const sparklePhase = puddleReverieWavePhase + s * 0.5;
          const sparkleX = puddleScreenX + (s / sparkleCount) * puddle.w + Math.sin(sparklePhase) * 2;
          const sparkleY = puddleScreenY + puddle.h - ((420 - puddleReverieTimer) / 420) * puddle.h * 2;
          
          // Check if sparkle is within puddle bounds
          const dx = sparkleX - puddleCenterX;
          const dy = sparkleY - puddleCenterY;
          const distanceFromCenter = Math.sqrt((dx * dx) / (puddle.w * puddle.w / 4) + (dy * dy) / (puddle.h * puddle.h / 4));
          
          if (distanceFromCenter <= 1) { // Only draw if inside puddle
            // Twinkle effect
            const twinkle = 0.6 + 0.4 * Math.sin(sparklePhase * 3);
            const sparkleSize = 1 + Math.sin(sparklePhase) * 0.5;
            
            // Draw sparkle cross pattern
            ctx.fillStyle = `hsla(${blueHue + 10}, 95%, 85%, ${twinkle * 0.8})`;
            ctx.fillRect(sparkleX - sparkleSize, sparkleY, sparkleSize * 2, 1); // horizontal
            ctx.fillRect(sparkleX, sparkleY - sparkleSize, 1, sparkleSize * 2); // vertical
            
            // Bright center dot
            ctx.fillStyle = `hsla(${blueHue + 10}, 100%, 95%, ${twinkle})`;
            ctx.fillRect(sparkleX, sparkleY, 1, 1);
          }
        }
      }
      
      // 4. Surface shimmer waves (horizontal waves across puddle)
      if (puddleReverieTimer > 180) {
        for (let w = 0; w < 3; w++) {
          const waveY = puddleScreenY + (puddle.h / 3) * w + Math.sin(puddleReverieWavePhase + w * 0.8) * 2;
          const waveAlpha = 0.3 + 0.2 * Math.sin(puddleReverieWavePhase * 1.5 + w);
          
          ctx.strokeStyle = `hsla(${blueHue}, 85%, 70%, ${waveAlpha})`;
          ctx.lineWidth = 0.5;
          ctx.beginPath();
          ctx.moveTo(puddleScreenX, waveY);
          
          // Wavy horizontal line
          for (let x = 0; x <= puddle.w; x += 2) {
            const waveOffset = Math.sin((x / puddle.w) * Math.PI * 2 + puddleReverieWavePhase) * 1;
            ctx.lineTo(puddleScreenX + x, waveY + waveOffset);
          }
          ctx.stroke();
        }
      }
      
      ctx.restore(); // Remove clipping
    }

    ctx.restore();
  }
}

// ‚îÄ‚îÄ‚îÄ DRAW RADIO TOWER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function drawRadioTower() {
  const parallax = 0.4;
  const towerBaseX = radioTower.x - playerX * parallax;
  const groundY = H - 20;
  const towerHeight = 110;
  const towerWidthBase = 5;
  const towerWidthTop = 1;
  const topLightHeight = 4;

  ctx.fillStyle = twilight > 0.4 ? "#4f5fa5" : "#3a3a6a";
  for (let y = 0; y <= towerHeight; y++) {
    const t = y / towerHeight;
    const width = towerWidthTop + Math.floor((towerWidthBase - towerWidthTop) * t);
    ctx.fillRect(towerBaseX - width, groundY - towerHeight + y, 1, 1);
    ctx.fillRect(towerBaseX + width, groundY - towerHeight + y, 1, 1);
  }

  for (let y = 0; y <= towerHeight; y += 4) {
    const t = y / towerHeight;
    const width = towerWidthTop + Math.floor((towerWidthBase - towerWidthTop) * t);
    ctx.fillRect(towerBaseX - width + (y % 2), groundY - towerHeight + y, width * 2, 1);
  }

  ctx.fillRect(towerBaseX, groundY - towerHeight - topLightHeight, 1, topLightHeight);

  const blinkAlpha = 0.3 + 0.3 * Math.sin(Date.now() / 300);
  ctx.fillStyle = `rgba(224,159,62,${blinkAlpha})`;
  ctx.fillRect(towerBaseX, groundY - towerHeight - topLightHeight - 1, 1, 1);
}

// ‚îÄ‚îÄ‚îÄ DRAW FIELD LINE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function drawFieldLine(){
  fieldLine.blades.forEach(blade => {
    const x = blade.x - playerX*0.5;
    const y = fieldLine.yBase - blade.height + blade.offset;

    ctx.fillStyle = blade.isFlower ? "#c8bfa0" : fieldLine.grassColor;

    ctx.fillRect(x, y, 2, blade.height);
  });
}

function drawUFO(){
  if(!ufo.active) return;

  const screenX = 220;
  const screenY = ufo.y;

  const blink = 0.6 + Math.sin(Date.now() / 120) * 0.4;
  ctx.globalAlpha = ufo.alpha * blink;

  ctx.fillStyle = "#1b1b2b";
  ctx.fillRect(screenX - 8, screenY, 16, 2);
  ctx.fillRect(screenX - 6, screenY - 2, 12, 2);

  ctx.fillStyle = "#f2e9e4";
  ctx.fillRect(screenX - 6, screenY - 2, 12, 2);
  ctx.fillRect(screenX - 4, screenY - 4, 8, 2);

  ctx.fillStyle = "rgba(242,233,228,0.35)";
  ctx.fillRect(screenX - 3, screenY + 2, 6, 2);

  ctx.globalAlpha = 1;
}

// ‚îÄ‚îÄ‚îÄ DRAW CAT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function drawCat() {
    if (!cat.active) return;

    // No parallax for cat - same layer as player (screen space)
    const screenX = cat.x - playerX; // Direct screen positioning, no parallax
    const screenY = cat.y;

    let flip = false;
    if (cat.interacting) {
        flip = true;
    }

    if (flip) {
        ctx.save();
        const centerX = screenX + 2;
        const centerY = screenY - 1;
        ctx.translate(centerX, centerY);
        ctx.scale(-1, 1);
        ctx.translate(-centerX, -centerY);
    }

    // --- Soft shadow under the cat ---
    ctx.fillStyle = "rgba(0,0,0,0.2)";
    ctx.fillRect(screenX - 3, screenY + 4, 8, 2);

    // --- Check for puddles for reflection ---
    let nearPuddle = puddlePixels.some(p => Math.abs(p.x - cat.x) < 3);

    if (nearPuddle) {
        ctx.save();
        ctx.translate(0, 0);
        ctx.scale(1, -1);
        ctx.globalAlpha = 0.25;

        let reflectY = -screenY - 2;

        // Body reflection
        ctx.fillStyle = "#d4a373";
        ctx.fillRect(screenX - 3, reflectY - 2, 6, 4);

        // Head reflection
        ctx.fillRect(screenX + 3, reflectY - 2, 3, 3);

        // Ears reflection
        ctx.fillRect(screenX + 3, reflectY - 4, 1, 2); // left ear
        ctx.fillRect(screenX + 5, reflectY - 4, 1, 2); // right ear

        // Tail reflection
        ctx.fillRect(
            screenX - 5,
            reflectY - 1 + Math.sin(cat.frame * Math.PI) * 1.5,
            2,
            1
        );

        // Legs reflection
        ctx.fillRect(screenX - 2, reflectY + 2 + ((cat.frame < 2) ? 0 : 1), 1, 2);
        ctx.fillRect(screenX,     reflectY + 2 + ((cat.frame < 2) ? 1 : 0), 1, 2);
        ctx.fillRect(screenX - 1, reflectY + 2 + ((cat.frame < 2) ? 1 : 0), 1, 2);
        ctx.fillRect(screenX + 1, reflectY + 2 + ((cat.frame < 2) ? 0 : 1), 1, 2);

        ctx.globalAlpha = 1;
        ctx.restore();
    }

    // --- Actual cat ---
    ctx.fillStyle = "#d4a373";

    // Body
    ctx.fillRect(screenX - 3, screenY - 2, 6, 4);

    // Head
    ctx.fillRect(screenX + 3, screenY - 2, 3, 3);

    // Ears (NEW ‚Äì one on each side)
    ctx.fillRect(screenX + 3, screenY - 4, 1, 2); // left ear
    ctx.fillRect(screenX + 5, screenY - 4, 1, 2); // right ear

    // Tail
    ctx.fillRect(
        screenX - 5,
        screenY - 1 + Math.sin(cat.frame * Math.PI) * 1.5,
        2,
        1
    );

    // Legs
    ctx.fillRect(screenX - 2, screenY + 2 + ((cat.frame < 2) ? 0 : 1), 1, 2);
    ctx.fillRect(screenX,     screenY + 2 + ((cat.frame < 2) ? 1 : 0), 1, 2);
    ctx.fillRect(screenX - 1, screenY + 2 + ((cat.frame < 2) ? 1 : 0), 1, 2);
    ctx.fillRect(screenX + 1, screenY + 2 + ((cat.frame < 2) ? 0 : 1), 1, 2);

    // Restore flip transformation
    if (flip) {
        ctx.restore();
    }
}

// ‚îÄ‚îÄ‚îÄ DRAW GEESE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function drawGeese() {
    geese.forEach(goose => {
        if (goose.state === "gone") return;
        
        const screenX = goose.x - playerX; // Same layer as player (no parallax)
        const screenY = goose.y + goose.bob; // Apply idle bob
        
        // Goose palette
        const bodyColor = "#C8C8C2";    // soft off-white
        const shadowColor = "#9FA1A0";  // shadow
        const neckColor = "#7E8386";    // neck
        const beakColor = "#B29A6C";    // desaturated orange
        const feetColor = "#7A6A4F";    // feet
        const outlineColor = "#4C4F52"; // outline
        
        if (goose.state === "idle") {
            // Standing goose - body (16x12 scaled down)
            ctx.fillStyle = bodyColor;
            ctx.fillRect(screenX - 4, screenY - 3, 8, 3);
            ctx.fillRect(screenX - 3, screenY, 6, 2);
            ctx.fillRect(screenX - 2, screenY + 2, 4, 1);
            
            // Head and neck (8x10 scaled down)
            ctx.fillStyle = neckColor;
            ctx.fillRect(screenX + 3, screenY - 5, 2, 4);
            ctx.fillRect(screenX + 2, screenY - 1, 3, 1);
            
            // Beak
            ctx.fillStyle = beakColor;
            ctx.fillRect(screenX + 5, screenY - 4, 1, 1);
            
            // Feet
            ctx.fillStyle = feetColor;
            ctx.fillRect(screenX - 1, screenY + 3, 1, 1);
            ctx.fillRect(screenX + 2, screenY + 3, 1, 1);
            
        } else if (goose.state === "takingOff") {
            // Flying goose - simple wing animation
            const wingFrame = Math.floor(goose.timer / 8) % 2; // Change every 8 frames
            
            ctx.fillStyle = bodyColor;
            // Body
            ctx.fillRect(screenX - 3, screenY - 2, 6, 2);
            
            // Wings (animated)
            if (wingFrame === 0) {
                // Wings up
                ctx.fillRect(screenX - 4, screenY - 4, 2, 2);
                ctx.fillRect(screenX + 2, screenY - 4, 2, 2);
            } else {
                // Wings down
                ctx.fillRect(screenX - 4, screenY, 2, 2);
                ctx.fillRect(screenX + 2, screenY, 2, 2);
            }
            
            // Head
            ctx.fillStyle = neckColor;
            ctx.fillRect(screenX + 2, screenY - 3, 2, 2);
        }
    });
}

// Initialize lamp positions and breathing
function initLampPositions() {
    // Calculate second lamp positions
    const firstSetEndX = lampPositions[lampPositions.length - 1];
    const offset = 480;
    const lampSpacing = 160;
    
    secondLampPositions = [];
    for (let i = 0; i < 3; i++) {
        secondLampPositions.push(firstSetEndX + offset + lampSpacing * i);
    }
    
    allLampPositions = [...lampPositions, ...secondLampPositions];
    
    // Initialize lamp breathing and wobble data for all lamps
    lampBreaths = allLampPositions.map(() => ({
        speed: 0.001 + detRandom() * 0.003,
        phase: detRandom() * Math.PI * 2,
        wobbleOffset: detRandom() * 0.3
    }));
    
    // Create sparkle particles for street lamps only
    const streetLamps = allLampPositions.map(x => ({ x, y: lampY, radius: 12 }));
    createLampParticles(streetLamps);
    
    // Rebuild wire sets after lamp positions are finalized
    wireSets = [
      {
        startX: lampPositions[0],
        endX: lampPositions[lampPositions.length - 1],
        y: lampY,
        curveAmplitude: 10,
        curveFrequency: 0.02
      },
      {
        startX: secondLampPositions[0],
        endX: secondLampPositions[secondLampPositions.length - 1],
        y: lampY,
        curveAmplitude: 10,
        curveFrequency: 0.02
      }
    ];
    
    if (DEBUG) console.log("Lamps initialized. Second set:", secondLampPositions);
    if (DEBUG) console.log("Wire sets rebuilt:", wireSets.length, "spans");
}

function drawLamps() {
    allLampPositions.forEach((xBase, index) => {
        const lampX = xBase - playerX*0.7;
        const poleHeight = 55;
        const poleY = 72;

        ctx.fillStyle = C.fence;
        ctx.fillRect(lampX, poleY, 2, poleHeight);

        const breathData = lampBreaths[index];
        const breath = 1 + Math.sin(Date.now() * breathData.speed + breathData.phase) * 0.1;
        const flicker = (detRandom() - 0.5) * 0.05;
        const y = 70;

        const lampCool = "#f2efe9";
        const lampWarm = "#e09f3e";
        const warmth = Math.min(Math.max((twilight - 0.2) / 0.6, 0), 1);
        const lampColor = lerpColor(lampCool, lampWarm, warmth);

        const twilightBoost = 0.6 + twilight * 0.6;

        const alphaLevels = [0.18, 0.1];
        const widths = [6, 9];

        for (let i = 0; i < alphaLevels.length; i++) {
            const wobble = Math.sin(Date.now()/1000 + i + index) * breathData.wobbleOffset;
            const finalAlpha = alphaLevels[i] * lampAlpha * breath * twilightBoost;
            
            ctx.fillStyle = `rgba(
                ${lampColor.match(/\d+/g)[0]},
                ${lampColor.match(/\d+/g)[1]},
                ${lampColor.match(/\d+/g)[2]},
                ${finalAlpha}
            )`;
            ctx.fillRect(lampX - widths[i]/2 + wobble, y + i*5, widths[i], 5);
        }

        const haloRadius = 3;
        for (let r = 0; r < haloRadius; r++) {
            const haloAlpha = (1 - r/haloRadius) * 0.15 + flicker;
            const finalHaloAlpha = haloAlpha * lampAlpha * breath * twilightBoost;
            ctx.fillStyle = `rgba(
                ${lampColor.match(/\d+/g)[0]},
                ${lampColor.match(/\d+/g)[1]},
                ${lampColor.match(/\d+/g)[2]},
                ${finalHaloAlpha}
            )`;
            ctx.fillRect(lampX - r, y - r, r*2 + 1, r*2 + 1);
        }

        if (detRandom() < 0.01) {
            ctx.fillStyle = `rgba(255,255,255,${lampAlpha * breath * twilightBoost})`;
            ctx.fillRect(lampX, y, 1, 1);
        }
    });

    if (lampAlpha < 1) {
        lampAlpha += lampFadeSpeed;
        if (lampAlpha > 1) lampAlpha = 1;
    }
}

// ‚îÄ‚îÄ‚îÄ NEW CURVED LAMP SET CONFIGURATION ‚îÄ‚îÄ‚îÄ
const lampY = 72;
const curveAmplitude = 10;
const curveFrequency = 0.02;

// ‚îÄ‚îÄ‚îÄ WIRE BIRD CONFIG ‚îÄ‚îÄ‚îÄ
const maxBirdsPerWire = 5; 

let wireSets = [];

const birds = [];

function initWireBirds() {
  birds.length = 0;
  wireSets.forEach((wire, wireIndex) => {
    const count = 2 + Math.floor(detRandom() * maxBirdsPerWire);
    for (let i = 0; i < count; i++) {
      const t = detRandom() * 0.9 + 0.05; 
      
      const x = wire.startX + t * (wire.endX - wire.startX);
      const sag = Math.sin(t * Math.PI) * wire.curveAmplitude;
      const y = wire.y + sag;
      
      birds.push({
        wireIndex,
        x,
        y,
        baseY: y,
        wingPhase: detRandom() * Math.PI * 2,
        headPhase: detRandom() * Math.PI * 2,
        flying: false,
        flightDelay: Math.floor(detRandom() * 60),
        speed: 1 + detRandom() * 0.5,
        returning: false,
        idleTimer: 0,
        targetX: x,
        targetY: y
      });
    }
  });
}

function updateAndDrawWireBirds() {
  birds.forEach(bird => {
    const wire = wireSets[bird.wireIndex];

    if (!bird.flying && !bird.returning) {
      if (playerX + 400 > bird.x && bird.flightDelay <= 0) {
        if (detRandom() < 0.02) {
          bird.flying = true;
        }
      } else {
        bird.flightDelay -= 1;
      }

      const headOffset = Math.sin(bird.headPhase) * 1.5;
      bird.headPhase += 0.01;

      ctx.fillStyle = '#ffffff';
      drawDot(Math.floor(bird.x - playerX * 0.7), Math.floor(bird.baseY + headOffset), '#ffffff', 2);
    } 

    else if (bird.flying && !bird.returning) {
      bird.x += bird.speed;
      bird.wingPhase += 0.3;
      const wingOffset = Math.sin(bird.wingPhase) * 2;
      ctx.fillStyle = '#ffffff';
      drawDot(Math.floor(bird.x - playerX * 0.7), Math.floor(bird.baseY - 10 + wingOffset), '#ffffff', 2);

      if (detRandom() < 0.005) { 
        bird.flying = false;
        bird.returning = true;
        bird.idleTimer = 60 + Math.floor(detRandom() * 120);
        
        bird.targetX = wire.startX + detRandom() * (wire.endX - wire.startX);
        const t = (bird.targetX - wire.startX) / (wire.endX - wire.startX);
        const sag = Math.sin(t * Math.PI) * wire.curveAmplitude;
        bird.targetY = wire.y + sag;
      }
    }

    else if (bird.returning) {
      if (bird.idleTimer > 0) {
        bird.idleTimer--;
      } else {
        bird.x += (bird.targetX - bird.x) * 0.05;
        bird.y += (bird.targetY - bird.y) * 0.05;

        bird.wingPhase += 0.2;
        const wingOffset = Math.sin(bird.wingPhase) * 2;
        ctx.fillStyle = '#ffffff';
        drawDot(Math.floor(bird.x - playerX * 0.7), Math.floor(bird.y - 10 + wingOffset), '#ffffff', 2);

        if (Math.abs(bird.x - bird.targetX) < 1 && Math.abs(bird.y - bird.targetY) < 1) {
          bird.returning = false;
          bird.baseY = bird.targetY;
        }
      }
    }
  });
}

function drawCurvedWire(x1, x2, y) {
  const segments = Math.abs(x2 - x1);
  ctx.beginPath();

  for (let i = 0; i <= segments; i++) {
    const t = i / segments;
    const x = x1 + (x2 - x1) * t;

    const sag = Math.sin(t * Math.PI) * curveAmplitude;
    const curveY = y + sag;

    if (i === 0) ctx.moveTo(x, curveY);
    else ctx.lineTo(x, curveY);
  }

  ctx.strokeStyle = C.fence;
  ctx.lineWidth = 1;
  ctx.stroke();
}

function drawSlackWire(x1, y1, x2, y2, sag = 4) {
    const segments = Math.max(8, Math.abs(x2 - x1) / 6);

    ctx.beginPath();
    for (let i = 0; i <= segments; i++) {
        const t = i / segments;
        const x = x1 + (x2 - x1) * t;

        // gentle sag using sine curve
        const y =
            y1 + (y2 - y1) * t +
            Math.sin(t * Math.PI) * sag;

        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
    }

    ctx.strokeStyle = C.fence;
    ctx.lineWidth = 1;
    ctx.stroke();
}

function drawCurvedWires() {
  if (gameEnded) return;

  for (let i = 0; i < secondLampPositions.length - 1; i++) {
    const x1 = secondLampPositions[i]     - playerX * 0.7;
    const x2 = secondLampPositions[i + 1] - playerX * 0.7;

    const y = lampY + Math.sin(Date.now() / 1200 + i) * 0.5;

    drawCurvedWire(x1, x2, y);
  }
}

function drawWires(){
  for(let i = 0; i < lampPositions.length - 1; i++){
    const a = lampPositions[i];
    const b = lampPositions[i + 1];

    const y = lampY + Math.sin(Date.now() / 1200 + i) * 0.5;

    drawCurvedWire(
      a - playerX*0.7,
      b - playerX*0.7,
      y
    );
  }
}

// ‚îÄ‚îÄ‚îÄ DRAW STREET SIGN ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function drawStreetSign(){
  const x = streetSign.x - playerX*0.6;
  const baseY = streetSign.y;

  ctx.fillStyle = streetSign.colorPole;
  ctx.fillRect(x, baseY - streetSign.poleHeight, 2, streetSign.poleHeight);

  const skyTopColor = "#7e75a6";
  const skyBottomColor = "#2b2d42";
  const dynamicSignColor = lerpColor(skyTopColor, skyBottomColor, twilight);

  ctx.fillStyle = dynamicSignColor;
  ctx.fillRect(
    x - 1, 
    baseY - streetSign.poleHeight - streetSign.signHeight, 
    streetSign.signWidth, 
    streetSign.signHeight
  );
}

// ‚îÄ‚îÄ‚îÄ DRAW PLAYER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Helper function to create plaid patterns
function createPlaidPattern(color1, color2, size = 4, diagonal = false) {
  const patternCanvas = document.createElement('canvas');
  patternCanvas.width = size;
  patternCanvas.height = size;
  const pctx = patternCanvas.getContext('2d');

  // Base fill
  pctx.fillStyle = color1;
  pctx.fillRect(0, 0, size, size);

  // Diagonal stripes
  if (diagonal) {
    pctx.strokeStyle = color2;
    pctx.lineWidth = 1;
    pctx.beginPath();
    pctx.moveTo(0, 0);
    pctx.lineTo(size, size);
    pctx.moveTo(-size/2, size/2);
    pctx.lineTo(size/2, size + size/2);
    pctx.stroke();
  } else {
    // simple vertical/horizontal stripes
    pctx.fillStyle = color2;
    pctx.fillRect(size/2, 0, 1, size);
    pctx.fillRect(0, size/2, size, 1);
  }

  return pctx.createPattern(patternCanvas, 'repeat');
}

// Helper function to lighten hex colors
function lightenColor(hex, percent) {
  // Convert hex to RGB
  const num = parseInt(hex.replace("#",""),16);
  let r = (num >> 16) & 0xff;
  let g = (num >> 8) & 0xff;
  let b = num & 0xff;

  // Lighten by percent (0‚Äì1)
  r += Math.round((255 - r) * percent);
  g += Math.round((255 - g) * percent);
  b += Math.round((255 - b) * percent);

  // Convert back to hex
  return "#" + ((r << 16) | (g << 8) | b).toString(16).padStart(6, '0');
}

function drawPlayer() {
  const px = player.x;
  const py = player.y;
  
  // Apply twilight dimming to outfit colors
  const dim = 1 - twilight * 0.3;
  
  // Helper function to apply dimming to hex colors
  function applyDim(color) {
    const rgb = parseInt(color.slice(1), 16);
    const r = Math.floor(((rgb >> 16) & 255) * dim);
    const g = Math.floor(((rgb >> 8) & 255) * dim);
    const b = Math.floor((rgb & 255) * dim);
    return `rgb(${r},${g},${b})`;
  }
  
  const topColor = applyDim(player.topColor);
  const bottomColor = applyDim(player.bottomColor);

  // --- Head bob only when walking ---
  let headBob = 0;
  if (moving) {
    headBob = Math.sin(Date.now() * 0.005) * 0.4; // 0.4 pixels amplitude when walking
  }
  const headY = py - 7 + headBob;

  // --- Body ---
  const bodyY = py - 4;

  // --- Grey gap between body and legs ---
  ctx.fillStyle = `rgba(${Math.floor(250 * (1 - twilight * 0.05))},${Math.floor(250 * (1 - twilight * 0.05))},${Math.floor(250 * (1 - twilight * 0.05))},0.5)`;
  ctx.fillRect(px, py + 2, 6, 1);

  // --- Legs animation ---
  ctx.fillStyle = bottomColor;
  if (stepFrame === 0) {
    // Standing pose
    ctx.fillRect(px + 1, py + 3, 2, 4); // Left leg
    ctx.fillRect(px + 3, py + 3, 2, 4); // Right leg
  } else {
    // Walking pose
    ctx.fillRect(px + 1, py + 4, 2, 3); // Left leg steps forward
    ctx.fillRect(px + 3, py + 3, 2, 3); // Right leg lifts slightly
  }

  // Shell pile from whistled seagulls
  if (shellPileCount > 0) {
    const pileBaseY = player.y + 6;
    ctx.fillStyle = "#FFD700";
    for (let i = 0; i < shellPileCount; i++) {
      const sy = pileBaseY + (i * 0.35);
      const pAlpha = Math.max(0.15, 0.8 - (i * 0.04));
      ctx.globalAlpha = pAlpha * (1 - twilight * 0.3);
      ctx.fillRect(player.x + 1 + ((i % 2) * 0.4), sy, 1.1, 0.7);
    }
    ctx.globalAlpha = 1;
  }

  // --- Body with plaid pattern (if applicable) ---
  if (player.stripe) {
    // Create pattern with twilight-aware colors
    const topPattern = createPlaidPattern(
      applyDim(player.topColor), 
      applyDim(player.stripe), 
      player.patternSize, 
      player.diagonal
    );
    ctx.fillStyle = topPattern;
  } else {
    ctx.fillStyle = topColor;
  }
  ctx.fillRect(px, bodyY, 6, 6);

  // --- Head (lighter than body) ---
  const headColor = lightenColor(player.topColor, 0.4);
  ctx.fillStyle = applyDim(headColor);
  ctx.fillRect(px + 1, headY, 4, 3);
  
  // --- Whistle mouth dot ---
  if (whistling && whistleDuration > 0) {
    ctx.fillStyle = "#000"; // black dot
    // Position on right or left side of face based on direction
    const mouthX = facingRight ? px + 4 : px + 1; // right side or left side
    const mouthY = headY + 2; // bottom of head
    ctx.fillRect(mouthX, mouthY, 1, 1);
  }
}

// üåßÔ∏è Smooth rain drawing (visual softness)
function drawRain(ctx) {
  if (rainIntensity < 0.01) return;

  ctx.fillStyle = '#9db4c0';
  rainDrops.forEach(r => {
    ctx.globalAlpha = r.alpha * rainIntensity;
    ctx.fillRect(r.x, r.y, 1, 4);
  });
  ctx.globalAlpha = 1;
}

// ‚îÄ‚îÄ‚îÄ DRAW SIDEWALK SPLASHES ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function drawSidewalkSplashes(){
  ctx.fillStyle="rgba(242,233,228,0.08)";
  sidewalkSplashes.forEach(s=>{
    ctx.fillRect(s.x, s.y, 1, 2);
  });
}

// ‚îÄ‚îÄ‚îÄ DRAW SPLASHES ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function drawSplashes(){
  splashes.forEach(s=>{
    const alpha = 0.06 + 0.04*(s.lifetime/20);
    ctx.fillStyle = `rgba(242,233,228,${alpha})`;
    ctx.fillRect(s.x, s.y, 2, 2);
  });
}

// ‚îÄ‚îÄ‚îÄ DRAW REFLECTIONS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function drawReflections(){
  // Skip reflection if moon is not providing light
  if (moonReflectionAlpha <= 0) return;
  
  ctx.save();
  
  // Ghost dock lamp reflection removed - was appearing below player
  
  const px=60, py=120;
  ctx.fillStyle = `rgba(242,233,228,${0.08 * moonReflectionAlpha})`;
  ctx.fillRect(px, 130, 6, 6);
  
  // Shell pile reflection
  if (shellPileCount > 0) {
    const refAlpha = (0.06 + (twilight * 0.08)) * moonReflectionAlpha;
    ctx.fillStyle = `rgba(255, 215, 0, ${refAlpha})`;
    const refCount = Math.min(5, shellPileCount);
    for (let i = 0; i < refCount; i++) {
      ctx.fillRect(px + 1.5, 131 + (i * 0.45), 1.4, 0.35);
    }
  }
  
  ctx.restore();
}

// ‚îÄ‚îÄ‚îÄ TWILIGHT OVERLAY ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function drawTwilightOverlay(){
  let alpha = 0.2 + twilight * 0.6; // Base twilight calculation
  
  // Fast fade out after particles appear (3 seconds)
  if (titleTimer >= 3 && titleTimer < 4) {
    const fadeProgress = (titleTimer - 3) / 1; // Fade over 1 second (very fast)
    alpha *= Math.max(0, 1 - fadeProgress);
  } else if (titleTimer >= 4) {
    alpha = 0; // Completely gone after 4 seconds
  }

  // Fill the whole canvas
  ctx.fillStyle = `rgba(0, 0, 50, ${alpha})`; // subtle blue tint
  ctx.fillRect(0, 0, W, H);
}

// ‚îÄ‚îÄ‚îÄ CACHED GRADIENTS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Pre-create gradients to avoid expensive creation in draw loops
let cachedTwilightGradient = null;
let cachedHorizonGradient = null;

function updateTwilightGradient() {
  const gradient = ctx.createLinearGradient(0, 0, 0, H);
  gradient.addColorStop(0, `rgba(10, 10, 50, ${twilight * 0.8})`); // top darker
  gradient.addColorStop(0.5, `rgba(30, 30, 70, ${twilight * 0.6})`); // mid horizon
  gradient.addColorStop(1, `rgba(50, 50, 90, ${twilight * 0.4})`); // bottom lighter
  cachedTwilightGradient = gradient;
}

function updateHorizonGradient() {
  const grad = ctx.createLinearGradient(0,0,0,H);
  grad.addColorStop(0, 'rgba(80,100,180,0.05)');
  grad.addColorStop(0.5, 'rgba(70,90,150,0.1)');
  grad.addColorStop(1, 'rgba(50,60,100,0.15)');
  cachedHorizonGradient = grad;
}

// ‚îÄ‚îÄ‚îÄ TWILIGHT GRADIENT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function drawTwilightGradient() {
  if (!cachedTwilightGradient) updateTwilightGradient();
  ctx.fillStyle = cachedTwilightGradient;
  ctx.fillRect(0, 0, W, H);
}

// ‚îÄ‚îÄ‚îÄ HORIZON GRADIENT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function drawHorizonGradient(){
  if (!cachedHorizonGradient) updateHorizonGradient();
  ctx.fillStyle = cachedHorizonGradient;
  ctx.fillRect(0,0,W,H);
}

function drawLeftFade() {
    const t = Math.min(
        1,
        Math.max(0, (LEFT_FADE_START - playerX) / (LEFT_FADE_START - LEFT_FADE_END))
    );

    if (t <= 0) return;

    ctx.fillStyle = `rgba(0,0,0,${t * 0.6})`;
    ctx.fillRect(0, 0, W, H);
}

// ‚îÄ‚îÄ‚îÄ DRAW NOISE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function drawNoise(){
  ctx.globalAlpha=0.03;
  for(let i=0;i<150;i++){
    ctx.fillStyle=detRandom()>0.5?"#000":"#fff";
    const x = detRandom()*W;
    const y = detRandom()*H;
    // Avoid drawing exactly at (0,0) to prevent corner pixel
    if (x >= 1 && y >= 1) {
      ctx.fillRect(x, y, 1, 1);
    }
  }
  ctx.globalAlpha=1;
}

// ‚îÄ‚îÄ‚îÄ DRAW ALL SCENE ELEMENTS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function draw() {
  if (gameEnded) {
    drawEndScreen();
    // Draw hint screen on top of everything if active
    hintScreen.draw(ctx, W, H);
    return; // skip all other draws
  }

  drawSky();
  drawTwilightOverlay();
  drawHorizonGradient();
  drawAtmosphericWash(ctx); // üå´Ô∏è Subtle moon phase atmosphere
  
  drawDistantSilhouettes();

  drawStars();
  drawShootingStars();
  drawPlayerShootingStars(ctx); // Cinematic player stars
  
  // üåßÔ∏è Draw rain (atmospheric layer)
  drawRain(ctx);
  
  // üåï Draw moon (between stars and clouds)
  drawMoon(ctx);
  
  drawClouds();

  drawTwilightGradient(); // Add gradient after background, before buildings

  drawBuildings();
  drawRadioTower();
  drawGeese(); // Draw geese behind grass
  drawFieldLine();
  
  // FIXED: Proper drawing order with consistent screen space
  drawWater();      // Water first (background layer)
  
  // üåï Draw moon reflection on water
  drawMoonReflection(ctx, 212, 24);
  
  drawStreet();     // Street stops at dock start
  drawSidewalk();   // Sidewalk stops at dock start
  drawDockTransition(); // Soft edge between sidewalk and water

  drawRain(ctx);
  drawSplashes();
  drawSidewalkSplashes();
  drawFireflies();
  drawMoths(); // Draw moths under lamps

  drawPuddles();    // Puddles only on street - moved here for visibility
  drawPuddleReflections(); // Reflections overlay puddles

  drawPlayer();
  drawPawprints(); // Draw pawprints on ground layer (under cat)
  drawCat(); // Draw the cat after player (same layer)
  drawDock();       // Move dock to same layer as poles and lamps
  drawLamps();
  drawLampParticles(ctx); // Draw sparkles on top of street lamps
  drawDockLampSparkles(ctx); // Draw dock lamp sparkles
  drawWires();
  drawCurvedWires();
  updateAndDrawWireBirds();
  drawStreetSign();

  drawUFO();
  drawUfoSparkles(); // Draw sparkles with UFO
  drawReflections();
  drawFence();
  drawFenceBars();
  
  drawSeagulls(ctx); // Draw seagulls on top of everything
  
  handleLeftBoundary(); // Handle left boundary fade and reset
  drawNightFog();
  drawNoise();
  drawLeftFade(); // Apply darkness fade last
  
  // Phase mood tint + subtle vignette (drawn last to cover everything)
  if (moodTintActive && moodTintColor.a > 0) {
    if (DEBUG) console.log(`Debug: Drawing mood tint - active=${moodTintActive}, alpha=${moodTintColor.a}, hue=${moodTintColor.h}`);
    
    // Soft global tint
    ctx.fillStyle = `hsla(${moodTintColor.h}, ${moodTintColor.s}%, ${moodTintColor.l}%, ${moodTintColor.a})`;
    ctx.fillRect(0, 0, W, H);

    // Fluorescent vignette ‚Äî edges glow with tint color
    if (!CACHED_GRADIENTS) initGradients();
    // Create dynamic vignette using cached base as template
    const vignetteGradient = ctx.createRadialGradient(W/2, H/2, 0, W/2, H/2, Math.max(W,H)/1.2);
    vignetteGradient.addColorStop(0, 'rgba(0,0,0,0)');
    vignetteGradient.addColorStop(1, `hsla(${moodTintColor.h}, ${moodTintColor.s * 0.8}%, ${moodTintColor.l * 0.4}%, ${moodVignetteStrength})`);
    ctx.fillStyle = vignetteGradient;
    ctx.fillRect(0, 0, W, H);
  } else if (moodTintActive) {
    if (DEBUG) console.log(`Debug: Mood tint active but alpha is 0 or less - alpha=${moodTintColor.a}`);
  }
}

// ‚îÄ‚îÄ‚îÄ MAIN ANIMATION LOOP ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let lastTime = 0;
function loop(timestamp) {
  if (!lastTime) lastTime = timestamp;
  const dt = (timestamp - lastTime) / 1000; // seconds
  lastTime = timestamp;
  
  frameCount++;
  
  if (gameState === 'title') {
    // Always draw title screen first
    titleScreen.draw(ctx, W, H);
    
    if (fadingToGame) {
      // Frame-rate independent fade (3 seconds total)
      titleFadeAlpha += 0.008 * dt * 60; // Scale to 60fps baseline
      
      // Draw black fade overlay
      ctx.fillStyle = `rgba(0, 0, 0, ${titleFadeAlpha})`;
      ctx.fillRect(0, 0, W, H);
      
      // Only transition to game when fade is completely black
      if (titleFadeAlpha >= 1.0) {
        resetToGameStart();
        titleFadeAlpha = 0;
        fadingToGame = false;
      }
    }
  } else {
    update(dt);
    draw();
  }
  
  requestAnimationFrame(loop);
}

// ===== TITLE SCREEN SYSTEM =====
// Insert this ENTIRE block right BEFORE the existing `initializeGame();` call (near end of <script>)
// This creates a title screen identical to hints (assumed: black bg + centered pixel text),
// but with "PRESS LEFT OR RIGHT". Fades to game start on input. Separate from ending loop.

// Title screen object (mirrors hintScreen structure/style)
const titleScreen = {
  draw(ctx, W, H) {
    // Black background (like hints/end)
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, W, H);

    // Subtle twilight gradient overlay (matches game mood)
    if (!CACHED_GRADIENTS) initGradients();
    ctx.fillStyle = CACHED_GRADIENTS.titleScreen;
    ctx.fillRect(0, 0, W, H);

    // Pixel-art text: "WALK LEFT OR RIGHT" (centered, multi-line, moon-white)
    ctx.fillStyle = 'rgba(235, 232, 225, 0.9)';  // Soft moon glow
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    // Large monospace pixel font
    ctx.font = 'bold 16px monospace';
    ctx.fillText('WALK', W/2, H*0.40);
    ctx.fillText('LEFT OR RIGHT', W/2, H*0.52);

    // Subtle glow/shadow
    ctx.fillStyle = 'rgba(200, 200, 220, 0.3)';
    ctx.fillText('WALK', W/2 + 1, H*0.40 + 1);
    ctx.fillText('LEFT OR RIGHT', W/2 + 1, H*0.52 + 1);
  }
};

// Fade-to-game function
function startGameFade() {
  fadingToGame = true;
}

// Reset & start game (extracted from initializeGame, NO loop call)
function resetToGameStart() {
  // Full reset to initial state
  playerX = playerStartX;
  twilight = 0;
  gameState = 'playing';
  gameEnded = false;  // Ensure not ended
  rainIntensity = 0; stopRain();  // Clear rain
  playerShootingStars = [];
  shellPileCount = 0;
  dockLampSparkles = [];
  
  // Reset other game state variables
  whistling = false;
  ghostActive = false;
  stillUnderGhost = 0;
  ghostTimer = 0;
  ghostWave = 0;
  ghostMorse = 0;
  puddleReverieActive = false;        // ‚ú® NEW
  puddleReverieTimer = 0;             // ‚ú® NEW
  stillOverPuddle = 0;                // ‚ú® NEW
  puddleReverieWavePhase = 0;         // ‚ú® NEW
  moodTintActive = false;
  moodTintTimer = 0;
  moodVignetteStrength = 0;
  newMoonEvilWinkActive = false;
  newMoonEvilWinkTimer = 0;
  newMoonEvilWinkFrame = 0;
  fullMoonSmileActive = false;
  fullMoonSmileTimer = 0;
  fullMoonSmileFrame = 0;
  catGlanceTriggered = false;
  catGlancing = false;
  catGlanceTimer = 0;
  catSkidding = false;
  catSkidTimer = 0;
  catFacing = 1;
  pawprints.length = 0; // Clear pawprints
  ufoTriggered = false;
  owlHooted = false;
  playerShootingStars = [];

  // Re-init world (from initializeGame, minus loop)
  initDock();
  
  // Init puddles using shared function
  initPuddles();
  
  initSeagulls();
  initLampPositions();
  initWireBirds();
  levelEndX = DOCK_CONFIG.startX + DOCK_CONFIG.length;
  // Allow player to reach dock and walk to end, accounting for parallax
  // Player needs to walk past dock end to see the end on screen
  maxPlayerX = levelEndX + 800 - 50; // ‚Üê FIXED: Walk 800px past dock, then move 50px left
  if (maxPlayerX < 0) maxPlayerX = 0; // ‚Üê SAFETY: Prevent negative values
  scheduleInitialEvents();
  createLampParticles(allLampPositions);  // If used

  if (DEBUG) console.log('Game restarted from title');
}

// ===== INITIALIZE EVERYTHING =====
function initializeGame() {
    if (DEBUG) console.log("Twilight initialized with seed:", WORLD_SEED);
    
    initGradients(); // ‚Üê ADD THIS LINE
    
    // FIXED: Initialize dock first so DOCK_CONFIG.startX is set
    initDock();
    
    // Initialize rain audio system (will start on first user interaction)
    // initRainAudio(); // Removed - audio must start after user gesture
    
    // Init puddles using shared function
    initPuddles();
    
    // Then initialize lamp positions (which needs dock positions)
    // IMPORTANT: wireSets are rebuilt here after secondLampPositions is populated
    initLampPositions();
    
    // Initialize wire birds AFTER wireSets are rebuilt
    initWireBirds();
    
    // Set level end to dock end (now DOCK_CONFIG.startX is known)
    levelEndX = DOCK_CONFIG.startX + DOCK_CONFIG.length;
    // Allow player to reach dock and walk to end, accounting for parallax
    // Player needs to walk past dock end to see the end on screen
    maxPlayerX = levelEndX + 800 - 50; // ‚Üê FIXED: Walk 800px past dock, then move 50px left
    if (maxPlayerX < 0) maxPlayerX = 0; // ‚Üê SAFETY: Prevent negative values
    
    // Schedule events (now levelEndX is known)
    scheduleInitialEvents();
    
    if (DEBUG) console.log("Dock starts at:", DOCK_CONFIG.startX, "(160px after last lamp pole)");
    if (DEBUG) console.log("Dock ends at:", levelEndX);
    if (DEBUG) console.log("Road ends at dock start, water begins");
    if (DEBUG) console.log("Clear 160px breathing room between last pole and dock");
    
    // Start the game loop
    requestAnimationFrame(loop);
}

// ‚îÄ‚îÄ‚îÄ START GAME ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
initializeGame();

</script>
</body>
</html>